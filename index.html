<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title>Planets!</title>

    <script id="fragment-shader-lib" type="notjs">
      #define M_PI 3.1415926535897932384626433832795
      #ifndef NOIZE3D
        #define NOIZE3D 8
      #endif
      #ifndef NOIZE4D
        #define NOIZE4D 5
      #endif
      precision highp float;

      //  Simplex 3D Noise
      //  by Ian McEwan, Stefan Gustavson (https://github.com/stegu/webgl-noise)
      vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
      vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
      float snoise(vec3 v){
        const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
        vec3 i  = floor(v + dot(v, C.yyy) );
        vec3 x0 =   v - i + dot(i, C.xxx) ;
        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min( g.xyz, l.zxy );
        vec3 i2 = max( g.xyz, l.zxy );
        vec3 x1 = x0 - i1 + 1.0 * C.xxx;
        vec3 x2 = x0 - i2 + 2.0 * C.xxx;
        vec3 x3 = x0 - 1. + 3.0 * C.xxx;
        i = mod(i, 289.0 );
        vec4 p = permute( permute( permute(
                   i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                 + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                 + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
        float n_ = 1.0/7.0; // N=7
        vec3  ns = n_ * D.wyz - D.xzx;
        vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)
        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
        vec4 x = x_ *ns.x + ns.yyyy;
        vec4 y = y_ *ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);
        vec4 b0 = vec4( x.xy, y.xy );
        vec4 b1 = vec4( x.zw, y.zw );
        vec4 s0 = floor(b0)*2.0 + 1.0;
        vec4 s1 = floor(b1)*2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));
        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
        vec3 p0 = vec3(a0.xy,h.x);
        vec3 p1 = vec3(a0.zw,h.y);
        vec3 p2 = vec3(a1.xy,h.z);
        vec3 p3 = vec3(a1.zw,h.w);
        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
        p0 *= norm.x;
        p1 *= norm.y;
        p2 *= norm.z;
        p3 *= norm.w;
        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
        m = m * m;
        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                      dot(p2,x2), dot(p3,x3) ) );
      }

      float noize_harm(vec3 pos, vec4 params) {
        float amplitude = 1.0, frequency = 1.0;
        float n = 0.0;

        for(int o = 0; o < NOIZE3D; o++) {
          n += amplitude * snoise(pos/params.x*frequency);
          amplitude *= params.y;
          frequency *= params.z;
        }
        return (n+1.0/2.0) * params.w;
      }

      //  Simplex 4D Noise
      //  by Ian McEwan, Stefan Gustavson (https://github.com/stegu/webgl-noise)
      float permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}
      float taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}
      vec4 grad4(float j, vec4 ip){
        const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);
        vec4 p,s;

        p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;
        p.w = 1.5 - dot(abs(p.xyz), ones.xyz);
        s = vec4(lessThan(p, vec4(0.0)));
        p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;

        return p;
      }

      float snoise(vec4 v){
        const vec2  C = vec2( 0.138196601125010504,  // (5 - sqrt(5))/20  G4
                              0.309016994374947451); // (sqrt(5) - 1)/4   F4
      // First corner
        vec4 i  = floor(v + dot(v, C.yyyy) );
        vec4 x0 = v -   i + dot(i, C.xxxx);

      // Other corners

      // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)
        vec4 i0;

        vec3 isX = step( x0.yzw, x0.xxx );
        vec3 isYZ = step( x0.zww, x0.yyz );
      //  i0.x = dot( isX, vec3( 1.0 ) );
        i0.x = isX.x + isX.y + isX.z;
        i0.yzw = 1.0 - isX;

      //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );
        i0.y += isYZ.x + isYZ.y;
        i0.zw += 1.0 - isYZ.xy;

        i0.z += isYZ.z;
        i0.w += 1.0 - isYZ.z;

        // i0 now contains the unique values 0,1,2,3 in each channel
        vec4 i3 = clamp( i0, 0.0, 1.0 );
        vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );
        vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );

        //  x0 = x0 - 0.0 + 0.0 * C
        vec4 x1 = x0 - i1 + 1.0 * C.xxxx;
        vec4 x2 = x0 - i2 + 2.0 * C.xxxx;
        vec4 x3 = x0 - i3 + 3.0 * C.xxxx;
        vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;

      // Permutations
        i = mod(i, 289.0);
        float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);
        vec4 j1 = permute( permute( permute( permute (
                   i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))
                 + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))
                 + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))
                 + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));
      // Gradients
      // ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)
      // 7*7*6 = 294, which is close to the ring size 17*17 = 289.

        vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;

        vec4 p0 = grad4(j0,   ip);
        vec4 p1 = grad4(j1.x, ip);
        vec4 p2 = grad4(j1.y, ip);
        vec4 p3 = grad4(j1.z, ip);
        vec4 p4 = grad4(j1.w, ip);

      // Normalise gradients
        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
        p0 *= norm.x;
        p1 *= norm.y;
        p2 *= norm.z;
        p3 *= norm.w;
        p4 *= taylorInvSqrt(dot(p4,p4));

      // Mix contributions from the five corners
        vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);
        vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);
        m0 = m0 * m0;
        m1 = m1 * m1;
        return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))
                     + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;
      }

      float noize_harm(vec4 pos, vec4 params) {
        float amplitude = 1.0, frequency = 1.0;
        float n = 0.0;

        for(int o = 0; o < NOIZE4D; o++) {
          n += amplitude * snoise((pos)/params.x*frequency);
          amplitude *= params.y;
          frequency *= params.z;
        }
        return (n+1.0/2.0) * params.w;
      }

      float N2(vec2 p)
      { // Dave Hoskins - https://www.shadertoy.com/view/4djSRW
        vec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));
          p3 += dot(p3, p3.yzx + 19.19);
          return fract((p3.x + p3.y) * p3.z);
      }

      vec2 spherize(vec2 pos) {
        float l = length(pos);
        float dr = asin(l) / M_PI * 2.0;
        return pos/l*dr;
      }

      vec3 hsl2rgb(vec3 c) {
        vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );
        return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));
      }

      vec3 rgb2hsl(vec3 c){
        float h = 0.0;
        float s = 0.0;
        float l = 0.0;
        float r = c.r;
        float g = c.g;
        float b = c.b;
        float cMin = min( r, min( g, b ) );
        float cMax = max( r, max( g, b ) );
        l = ( cMax + cMin ) / 2.0;
        if ( cMax > cMin ) {
          float cDelta = cMax - cMin;
          s = l < .0 ? cDelta / ( cMax + cMin ) : cDelta / ( 2.0 - ( cMax + cMin ) );
          if ( r == cMax ) {
            h = ( g - b ) / cDelta;
          } else if ( g == cMax ) {
            h = 2.0 + ( b - r ) / cDelta;
          } else {
            h = 4.0 + ( r - g ) / cDelta;
          }
          if ( h < 0.0) {
            h += 6.0;
          }
          h = h / 6.0;
        }
        return vec3(h, s, l);
      }

      float sech(float x) {
        return 2. / (pow(2.71828, x) + pow(2.71828, -x));
      }

      vec4 colormix(vec4 c0, vec4 c1) {
        float a01 = (1. - c0.a)*c1.a + c0.a;
        return vec4( ((1. - c0.a)*c1.a*c1.rgb + c0.a*c0.rgb) / a01, a01);
      }
    </script>

    <script id="vertex-shader-2d" type="notjs">
      attribute vec2 a_position;
      uniform vec2 u_resolution;
      
      uniform vec2 u_position;
      uniform vec2 u_scale;
      uniform float u_angle;
      
      varying vec2 v_rpos;

      void main() {
        vec2 rotation = vec2(sin(u_angle), cos(u_angle));
        vec2 rotated = vec2(
          a_position.x * rotation.y + a_position.y * rotation.x,
          a_position.y * rotation.y - a_position.x * rotation.x
        );
        vec2 position = rotated*u_scale + u_position;
        vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;
        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
        v_rpos = a_position;
      }
    </script>

    <script id="vertex-shader-rings" type="notjs">
      attribute vec2 a_position;
      uniform vec2 u_resolution;
      uniform vec2 u_position;
      uniform vec2 u_scale;
      uniform float u_angle;
      varying vec2 v_rpos, v_tpos;

      void main() {
        vec2 rotation = vec2(sin(u_angle), cos(u_angle));
        vec2 scaled = a_position * u_scale;
        vec2 position = vec2(
          scaled.x * rotation.y + scaled.y * rotation.x,
          scaled.y * rotation.y - scaled.x * rotation.x
        ) + u_position;
        vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;
        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
        v_rpos = a_position;
        v_tpos = (v_rpos+1.)/2.;
      }
    </script>

    <script id="fragment-shader-planet-texture" type="notjs">
      varying vec2 v_rpos;

      uniform int u_type;
      uniform float u_jpfactor;
      uniform vec4 u_heightmap;
      uniform vec4 u_moisturemap;
      uniform float u_random;
      uniform vec2 u_grain;
      uniform float u_craters;

      float craters() {
        if (u_craters <= 0.) return 0.;
        vec2 coord = v_rpos/4.;
        float result = 0.;
        for (float i=1.;i<=6.;++i){
          vec2 scoord = coord * vec2(i*i);
          vec2 rscoord = vec2(floor(scoord.x+0.5), floor(scoord.y+0.5));

          if (rscoord.x == i*i) {
            scoord.x -= rscoord.x;
            rscoord.x = 0.;
          }

          vec2 randInndex = vec2(rscoord + u_random + i);

          if (N2(randInndex) > 1.-u_craters){
            float dsize = N2(randInndex+10.)/2.;
            vec2 dpos = vec2(N2(randInndex+20.)*2.-1., N2(randInndex+30.)*2.-1.) * dsize/2.;
            
            vec2 ccoord = rscoord - scoord + dpos;
            float a = atan(ccoord.y, ccoord.x);
            float d = length(ccoord);

            dsize += noize_harm(vec3(cos(a), sin(a), rscoord.x*rscoord.y*i), u_heightmap) / (2./d);

            float creterHeight = N2(randInndex+40.);

            float ln = d * 2. + dsize;
            if (ln > 0.) {
              float outer = max(0., sech(ln*2.) - sech(2.));
              float inner = 2. * pow(ln, 2.) - 0.5;
              float center = max(0., sech(ln*8.) - sech(8.) - 0.2 - N2(randInndex+50.));
              float crater = min(inner, outer);
              crater += center;
              crater = max(-N2(randInndex+50.)/5., crater);
              result += crater * creterHeight;
            }
          }
        }
        return result;
      }

      void main() {
        float height, moisture;

        vec2 loopCoord = v_rpos * M_PI/2.0 + vec2(0.0, u_random);
        vec3 noizeCoord = vec3(cos(loopCoord.x), sin(loopCoord.x), loopCoord.y);

        if (u_type == 0){
          height = noize_harm(noizeCoord, u_heightmap);
          moisture = noize_harm(vec3(0,noize_harm(noizeCoord+vec3(0,0,10000.0), u_heightmap)*u_jpfactor, loopCoord.y), u_heightmap);
        } else if (u_type == 1) {
          height = noize_harm(vec3(0,noize_harm(noizeCoord, u_heightmap)*u_jpfactor, loopCoord.y), u_heightmap);
          moisture = noize_harm(vec3(0,noize_harm(noizeCoord+vec3(0,0,10000.0), u_heightmap)*u_jpfactor, loopCoord.y), u_heightmap);
        } else {
          noizeCoord.z += sin(noize_harm(noizeCoord, u_moisturemap) * M_PI * 2.) * .1;
          height = noize_harm(vec3(0,noize_harm(noizeCoord*vec3(1,1,u_jpfactor), u_heightmap)*u_jpfactor, loopCoord.y), u_heightmap);
          moisture = noize_harm(vec3(0,noize_harm(noizeCoord*vec3(1,1,u_jpfactor*2.), u_heightmap)*u_jpfactor, loopCoord.y), u_heightmap);
        }

        float grain = N2(v_rpos+vec2(u_random, 0)) > u_grain.x ? N2(v_rpos+100.)*u_grain.y : 0.;
        gl_FragColor = vec4((height+1.)/2., (moisture+1.)/2., grain, 1);
        gl_FragColor.x += craters();
        gl_FragColor.x /= 1.5;
      }
    </script>

    <script id="fragment-shader-planet-lava-glow" type="notjs">
      #define q 0.1
      #define r 30.
      varying vec2 v_rpos;
      uniform sampler2D u_image;
      uniform vec2 u_scale;
      uniform float u_waterlevel;

      float v(vec2 p) {
        vec4 t = texture2D(u_image, (v_rpos/2.0)+p);
        return t.x < u_waterlevel ? 1. : 0.;
      }

      void main() {
        vec2 pixel = vec2(1.0, 1.0) / u_scale;
        float h=0., n=0.;

        for (float x=-r;x<=r;++x) {
          for (float y=-r;y<=r;++y) {
            vec2 p = vec2(x,y), p1 = p/r;
            float t = max(0., (1.-length(p1)));
            h += v(pixel*vec2(x,y))*t;
            n+=t;
          }
        }

        gl_FragColor = texture2D(u_image, (v_rpos/2.0));
        gl_FragColor.z = h/n/4.;
      }
    </script>

    <script id="fragment-shader-normalmap" type="notjs">
      varying vec2 v_rpos;
      uniform sampler2D u_image;
      uniform float u_bumpy;
      uniform int u_coloring;
      uniform float u_waterlevel;

      float height(vec2 d) {
        float h = texture2D(u_image, v_rpos/vec2(2, -2)+d).x;
        if (u_coloring == 1 || u_coloring == 2) {
          if (h<u_waterlevel)
            return u_waterlevel;
        }
        return h;
      }

      void main() {
        float s=0.001;
        float tl = height(vec2(-s, -s));
        float l = height(vec2(-s, 0));
        float bl = height(vec2(-s, s));
        float b = height(vec2(0, s));
        float br = height(vec2(s, s));
        float r = height(vec2(s, 0));
        float tr = height(vec2(s, -s));
        float t = height(vec2(0, -s));
        vec3 bump = normalize(vec3(tr + 2. * r + br - tl - 2. * l - bl, bl + 2. * b + br - tl - 2. * t - tr, -1./u_bumpy));
        gl_FragColor = vec4(-bump, 1);
      }
    </script>

    <script id="fragment-shader-cloudmap" type="notjs">
      varying vec2 v_rpos;
      uniform sampler2D u_image;
      uniform int u_coloring;
      uniform float u_waterlevel;
      uniform float u_random;

      void main() {
        vec2 loopCoord = v_rpos * M_PI/2.0 + vec2(0.0, u_random*2.+10.);
        vec3 noizeCoord = vec3(cos(loopCoord.x), sin(loopCoord.x), loopCoord.y);

        float windMask = clamp((noize_harm(noizeCoord, vec4(2,0.5,1,1))+1.)/2., 0., 1.);
        float disp = noize_harm(noizeCoord*vec3(1,1,4), vec4(6,0.1,1,1)) * windMask;

        gl_FragColor = vec4((disp+1.)/2., 0, 0, 1);
      }
    </script>

    <script id="fragment-shader-planet" type="notjs">
      varying vec2 v_rpos;
      varying vec2 v_tpos;

      uniform sampler2D u_image;
      uniform sampler2D u_bump;
      uniform sampler2D u_cloudmap;
      uniform vec3 u_groundcolor;
      uniform vec3 u_groundcolor2;
      uniform vec3 u_seacolor;
      uniform vec2 u_climate;
      uniform vec3 u_lightdirection;
      uniform vec3 u_lightcolor;
      uniform float u_lightambient;
      uniform float u_albedo;
      uniform float u_rotation;
      uniform float u_random;
      uniform float u_seashine;
      uniform float u_waterlevel;

      uniform vec4 u_clouds;
      uniform float u_wind;
      uniform float u_cloudy;
      uniform float u_cloudchange;
      uniform float u_glow;

      vec3 color_sea(vec2 pos, vec4 tex) {
        float height = tex.x;
        float moisture = tex.y;
        float climate = (u_climate.y + (u_climate.x-u_climate.y) * (1.-cos(pos.y))) + 0.1;
        float el = climate + pow(height, 3.0);

        vec3 land = vec3(height+tex.z)*u_groundcolor + vec3(1.0-moisture)*u_groundcolor2;

        if (height < u_waterlevel) {
          vec3 sea = min(u_seacolor*max(height, u_waterlevel/1.5)+tex.z/10., 1.0);
          land = mix(sea, land, smoothstep(u_waterlevel*0.9, u_waterlevel, height));
        }
        if(el > 0.9) {
          vec3 snow = vec3(height/1.5+tex.z+1.);
          land = mix(land, snow, smoothstep(0.8, 1., el));
        }
        return land;
      }

      vec3 color_lava(vec4 tex, float light) {
        float height = tex.x;
        float moisture = tex.y;
        vec3 land = vec3(height)*u_groundcolor + vec3(1.0-moisture)*u_groundcolor2;
        vec3 sea;

        if (height < u_waterlevel) {
          sea = u_seacolor / max(u_lightambient, light)*5.;
          land = mix(sea, land, smoothstep(u_waterlevel*0.9, u_waterlevel, height));
        }
        land += u_seacolor * tex.z / max(u_lightambient, light)*5.;
        return land;
      }

      vec3 color(vec4 tex) {
        return tex.x*u_groundcolor + (1.0-tex.y)*u_groundcolor2 + tex.z*(u_seacolor);
      }

      float specular(vec3 normal) {
        const vec3 surfaceToViewDirection = vec3(0,0,1); //normalized
        vec3 halfVector = normalize(normalize(u_lightdirection) + surfaceToViewDirection);
        return pow(dot(normal, halfVector), 100.)*u_seashine;
      }

      float clouds(vec2 spherized, float lengthSq2) {
        vec2 spherizedCoordTex = spherized/vec2(4,2)-vec2(-u_rotation/4.0,-0.5);
        vec3 cloudCoord = vec3(spherized.x+u_rotation*u_wind, spherized.y+u_random+20000.0, u_rotation*u_cloudchange);
        cloudCoord.z += texture2D(u_cloudmap, spherizedCoordTex).x*2.-1.;
        float v = noize_harm(cloudCoord, u_clouds*vec4(1., (1.5-pow(lengthSq2, 4.))/2., 1., lengthSq2+1.));
        return max(v-u_cloudy, 0.);
      }

      void main() {
        vec3 colour_value;
        float clouds_value;
        float light, specularlight;
        float lengthSq2 = v_rpos.x*v_rpos.x + v_rpos.y*v_rpos.y;

        if (lengthSq2 < 1.0) {
          vec2 spherized = spherize(v_rpos);
          vec2 spherizedCoordTex = spherized/vec2(4,2)-vec2(-u_rotation/4.0,-0.5);
          vec4 tex = texture2D(u_image, spherizedCoordTex);

          vec3 bump = texture2D(u_bump, spherizedCoordTex).xyz;

          #if ATMOSPHERE != 0
            clouds_value = clouds(spherized, lengthSq2);
            bump.xy *= (1.-clamp(clouds_value, 0., 1.));
          #endif

          vec3 normal = normalize(vec3(v_rpos, sqrt(1.0 - lengthSq2)) + bump);
          light = dot(
            normal,
            normalize(u_lightdirection)
          );

          #if COLORING == 0
            colour_value = color(tex);
          #elif COLORING == 1
            colour_value = color_sea(spherized, tex);
            specularlight = max(0., specular(normal)*(1.-smoothstep(u_waterlevel*0.9, u_waterlevel, tex.x))-clouds_value);
          #else
            colour_value = color_lava(tex, light);
          #endif

          vec2 glowd = v_rpos - normalize(u_lightdirection).xy/10.;
          float glow = max(0., glowd.x*glowd.x + glowd.y*glowd.y-0.5);
          light=max(pow(glow, 2.)*u_glow*u_lightambient, light);

          #if ATMOSPHERE != 0
            float shadow_value;
            clouds_value += glow/5.*u_glow;
            if(clouds_value<1.)
              shadow_value = clouds(spherize(v_rpos+normalize(u_lightdirection).xy/50.), lengthSq2);
            light -= shadow_value/2. * max(0., 1.-clouds_value);
          #endif

          gl_FragColor = vec4((colour_value+clouds_value)/2. * max(light, u_lightambient) * u_lightcolor * u_albedo + specularlight, smoothstep(1.,0.95,lengthSq2));
        } else {
          discard;
        }
      }
    </script>

    <script id="fragment-shader-asteroid-texture" type="notjs">
      varying vec2 v_rpos;

      uniform float u_random;
      uniform float u_rough;
      vec4 noize = vec4(2,u_rough,2.5,1);

      void main() {
        float r = noize_harm(vec3(v_rpos, u_random), noize);

        float lengthSq2 = v_rpos.x*v_rpos.x + v_rpos.y*v_rpos.y;
        if (lengthSq2 < 0.5 + r/2.0) {
          gl_FragColor = vec4(r, sqrt(2.0 - lengthSq2), 0, 1);
        } else {
          discard;
        }
      }
    </script>
    
    <script id="fragment-shader-asteroid" type="notjs">
      varying vec2 v_rpos;

      uniform sampler2D u_image;
      uniform vec3 u_color;
      uniform float u_random;
      uniform vec3 u_lightdirection;
      uniform float u_lightambient;

      void main() {
        vec4 tex = texture2D(u_image, (v_rpos/2.)+0.5);
        if (tex.w > 0.) {
          float light = dot(
            normalize(vec3(v_rpos, tex.y)),
            normalize(u_lightdirection)
          );
          gl_FragColor = vec4(u_color * max(light * tex.x, u_lightambient), 1);
        } else {
          discard;
        }
      }
    </script>

    <script id="fragment-shader-rings-texture" type="notjs">
      varying vec2 v_rpos;
      uniform float u_random;
      uniform float u_innerradius;
      uniform float u_transparency;
      uniform vec3 u_color;
      vec4 noize = vec4(2,0.8,2.5,1);

      float v(float length) {
        return clamp(noize_harm(vec3(length, 0, u_random), noize), 0., 1.);
      }

      void main() {
        float length = length(v_rpos);
        if (length > u_innerradius && length < 1.0) {
          float a = atan(v_rpos.y, v_rpos.x);
          float x = v(length);
          vec3 color = hsl2rgb(rgb2hsl(u_color)+vec3((v(length+10.)-0.5)/1.,0,0));
          gl_FragColor = vec4(color, x * smoothstep(1.,0.8,length) * smoothstep(u_innerradius,u_innerradius+0.1,length) * (1.0-u_transparency));
        } else {
          discard;
        }
      }
    </script>

    <script id="fragment-shader-rings" type="notjs">
      varying vec2 v_rpos, v_tpos;

      uniform sampler2D u_image;
      uniform float u_bf;
      uniform float u_angle;
      uniform float u_innerradius;

      void main() {
        float len = length(v_rpos);
        float a = atan(v_rpos.y, v_rpos.x);
        float side_mask = step(0., u_bf*v_rpos.y);
        if (len > u_innerradius && len < 1.0 && side_mask>0.) {
          vec4 tex = texture2D(u_image, v_tpos, cos((a+M_PI/2.)*2.)*2.);
          gl_FragColor = vec4(tex.rgb, tex.a);
        } else {
          discard;
        }
      }
    </script>

    <script id="fragment-shader-sun" type="notjs">
      varying vec2 v_rpos;

      uniform vec3 u_color;
      uniform float u_random;
      uniform vec2 u_shiny;
      uniform float u_transparency;
      uniform float u_rotation;
      uniform vec4 u_rays;

      void main() {
        float length = length(v_rpos);

        if (length < 1.0) {
          if (length > 1.0 / (u_shiny.x+1.0)) {
            float a = atan(v_rpos.y, v_rpos.x)*2.0 + u_rotation/2.0;
            float rays = max(noize_harm(vec3(cos(a), sin(a), length+u_rotation), u_rays)+0.5, 1.);
            float center = (1.0/length-1.0)/u_shiny.x;
            float brightness = center + (1.0 - length) * rays * u_shiny.y;
            gl_FragColor = vec4(u_color * brightness,  brightness);
          } else {
            gl_FragColor = vec4(1);
          }
        } else {
          discard;
        }
      }
    </script>

    <script id="fragment-shader-fill" type="notjs">
      varying vec2 v_rpos;
      uniform vec3 u_color;
      void main() {
        gl_FragColor = vec4(u_color, 1);
      }
    </script>

    <script id="fragment-shader-flame" type="notjs">
      varying vec2 v_rpos;
      uniform vec3 u_color;

      uniform float u_frame;
      uniform float u_thrust;

      void main() {
        float y = v_rpos.y/2.;
        float w = length((v_rpos/vec2(1, u_thrust)-vec2(0, 1.))*vec2(0.6+y, 1));
        w += sin(y*10.-u_frame)*0.2;
        if (w<1.) {
          vec4 noize = vec4(6.*u_thrust, 0.8*u_thrust, 2.5, 1.);
          float color = noize_harm(vec3(v_rpos*vec2(w, 1)+vec2(0, -u_frame*0.4), 0), noize)*(2.-u_thrust);
          gl_FragColor = vec4(vec3(u_color.r*color, u_color.g*color, u_color.b*(1.-y)), (1.-w)*color);
        } else {
          discard;
        }
      }
    </script>

    <script id="fragment-shader-rocket" type="notjs">
      varying vec2 v_rpos;
      uniform vec3 u_color;
      uniform vec3 u_lightdirection;

      uniform float u_wide;//=0.33;
      uniform float u_curvy;//=0.8;
      uniform vec2 u_wing1;//=vec2(0.7, -1);
      uniform float u_wing1start;//=-0.2;
      uniform float u_wing1end;//=-0.9;
      uniform vec2 u_wing2;//=vec2(0.5,0);
      uniform float u_wing2start;//=0.6;
      uniform float u_wingtipspos;//=0.9 ;
      uniform float u_wingtipslength;//=0.5;
      uniform vec2 u_cockpit;//=vec2(0.1, 0.4);
      uniform vec2 u_cockpitpos;//=vec2(0, -0.4);
      uniform float u_cockpitwidth;//1.;
      uniform vec3 u_cockpitcolor;//=vec3(0.5, 0.7, 1);
      uniform float u_ring1;//=0.4;
      uniform float u_ring2;//=0.9;
      uniform float u_ring3;//=0.93;
      uniform vec3 u_ringscolor;//=vec3(1, 0.5, 0.5);
      
      float specular(vec3 normal) {
        const vec3 surfaceToViewDirection = vec3(0,0,1); //normalized
        vec3 halfVector = normalize(normalize(u_lightdirection) + surfaceToViewDirection);
        return pow(dot(normal, halfVector), 100.)*1.;
      }

      float line(vec2 p1, vec2 p2) {
          float a = p1.y-p2.y;
          float b = p2.x-p1.x;
          return a*v_rpos.x+b*v_rpos.y+p1.x*p2.y-p2.x*p1.y;
      }

      float drawLine(vec2 p1, vec2 p2) {
        const float thickness = 0.02;
        float a = abs(distance(p1, v_rpos));
        float b = abs(distance(p2, v_rpos));
        float c = abs(distance(p1, p2));
        if ( a >= c || b >=  c ) return 0.0;
        float p = (a + b + c) * 0.5;
        float h = 2. / c * sqrt( p * ( p - a) * ( p - b) * ( p - c));
        return mix(1.0, 0.0, smoothstep(0.5 * thickness, 1.5 * thickness, h));
      }

      float triangle(vec2 p1, vec2 p2, vec2 p3){
        const float smooth = 0.02;
        return smoothstep(-smooth, smooth, line(p1, p2))*smoothstep(-smooth, smooth, line(p2, p3))*smoothstep(-smooth, smooth, line(p3, p1));
      }

      void main() {
        float y = 1.-(v_rpos.y+1.)/2.;
        float w = sin(y*M_PI*u_curvy)*u_wide;

        vec2 wingtip;
        wingtip.x = u_wing1.x*u_wingtipspos;
        wingtip.y = mix(u_wing1.y, (u_wing1start+u_wing1end)/2., 1.-u_wingtipspos);
        gl_FragColor = vec4(u_color*0.7, max(gl_FragColor.a, triangle(u_wing1*vec2(-1,1), vec2(0.,u_wing1end), vec2(0.,u_wing1start))));
        gl_FragColor = vec4(u_color*0.7, max(gl_FragColor.a, triangle(u_wing1,            vec2(0.,u_wing1start), vec2(0.,u_wing1end))));
        gl_FragColor = vec4(u_color*0.7, max(gl_FragColor.a, triangle(u_wing2, vec2(0.,u_wing2start),u_wing2*vec2(-1,1))));
        gl_FragColor = vec4(u_color*0.7, max(gl_FragColor.a, drawLine(wingtip, wingtip+vec2(0, u_wingtipslength))));
        gl_FragColor = vec4(u_color*0.7, max(gl_FragColor.a, drawLine(wingtip*vec2(-1,1), wingtip*vec2(-1,1)+vec2(0, u_wingtipslength))));

        if (abs(v_rpos.x)<w) {
          vec3 shade = vec3(1.);
          vec2 p = v_rpos/vec2(w, 1./u_wide);

          shade = mix(shade, shade*u_ringscolor, smoothstep(u_ring1-0.02, u_ring1, y)*smoothstep(u_ring1+0.02, u_ring1, y));
          shade = mix(shade, shade*u_ringscolor, smoothstep(u_ring2-0.02, u_ring2, y)*smoothstep(u_ring2+0.02, u_ring2, y));
          shade = mix(shade, shade*u_ringscolor, smoothstep(u_ring3-0.02, u_ring3, y)*smoothstep(u_ring3+0.02, u_ring3, y));

          vec2 cockpit = (v_rpos-u_cockpitpos)/u_cockpit;
          cockpit.x /= cockpit.y+u_cockpitwidth;
          float cockpitstep = smoothstep(1., 0.8, length(cockpit));
          cockpitstep = smoothstep(1., 0.8, length(cockpit));
          shade = mix(shade, u_ringscolor, smoothstep(1.1, 1., length(cockpit)));
          shade = mix(shade, u_cockpitcolor, cockpitstep);
          p = mix(p, cockpit,  cockpitstep);
          vec3 normal = normalize(vec3(p, sqrt(1.0 - pow(length(p), 2.))));
          float light = dot(
            normalize(normal),
            normalize(u_lightdirection)
          );
          float specularlight = specular(normal);
          light = max(.2, light+specularlight);

          gl_FragColor = vec4(u_color*light*shade, max(gl_FragColor.a, smoothstep(w,w*0.85,abs(v_rpos.x))*smoothstep(1., .95, y)));
        }
      }
    </script>

    <script id="fragment-shader-space-texture" type="notjs">
      varying vec2 v_rpos;

      uniform vec2 u_scale;
      uniform float u_rotation;
      uniform float u_random;
      uniform float u_dust;
      uniform float u_stars;
      uniform float u_smallstars;

      vec2 star(vec2 craterpos, float scale, float glow) {
        vec2 p = abs(v_rpos-craterpos);
        p.x = min(p.x-1., p.x);
        p.y = min(p.y-1., p.y);
        float l = length(p);
        float lr = l;
        #ifdef OVEREXPOSURE
        if (scale > 0.011){
          lr = l * max(0.001, pow((abs(abs(p.x)-abs(p.y))), 0.9))*300.;
          scale *= N2(craterpos+1000.)+0.5;
          return vec2((lr < scale ? 1. - lr/scale : 0.)*2., l < scale*glow ? 1. - l/(scale*glow) : 0.);
        }
        #endif
        return vec2(lr < scale ? 1. - lr/scale : 0., l < scale*glow ? 1. - l/(scale*glow) : 0.);
      }

      vec2 stars() {
        vec2 s;
        float pr = N2(v_rpos+vec2(u_random, 0));
        float bigstar;
        float size;
        if (pr>u_smallstars)
          s.x = N2(v_rpos+100.);
        for (float i=0.;i<1000.;++i) {
          bigstar = N2(vec2(i, u_random));
          if (bigstar > u_stars) {
            vec2 c = vec2(N2(vec2(i+u_random)), N2(vec2(i+u_random+100.)))*2.-1.;
            size = 10.;
            #ifdef OVEREXPOSURE
            if (bigstar > OVEREXPOSURE) size *= 2.;
            #endif
            s += star(c, pow(N2(c), 2.)/length(u_scale)*size, 10.);
          }
        }
        return s;
      }

      void main() {
        vec2 loopCoord = v_rpos * vec2(2, 1) * M_PI;
        vec4 noizeCoord = vec4(
          cos(loopCoord.x/2.)+u_random,
          sin(loopCoord.x/2.),
          cos(loopCoord.y)+u_random,
          sin(loopCoord.y)
        );
        vec4 heightmap = vec4(10,.6,2.5,1);

        vec2 s = stars();

        float r,g,b,d=1.;
        r = noize_harm(noizeCoord+u_random*100.0+1000.0, heightmap)/10.;
        g = noize_harm(noizeCoord+u_random*200.0+2000.0, heightmap)/10.;
        b = noize_harm(noizeCoord+u_random*300.0+3000.0, heightmap)/10.;
        if (u_dust>0.) {
          s.x/=2.;
          d = noize_harm(noizeCoord+u_random*300.0+4000.0, vec4(1,.7,2.5,1))+s.y;
        }

        gl_FragColor = vec4(vec3(
          clamp(r, 0., 4.)*0.8,
          clamp(g, 0., 4.)*0.4,
          clamp(b, 0., 4.)*0.99
          )*d+vec3(s.x*d), 1
        );

        // if (mod(v_rpos.x+0.05, 0.5)<0.01)gl_FragColor = vec4(0,0,1,1);
        // if (mod(v_rpos.y+0.05, 0.5)<0.01)gl_FragColor = vec4(0,1,0,1);
        // gl_FragColor.x += v_rpos.x;
        // gl_FragColor.y += v_rpos.y;
      }
    </script>

    <script id="vertex-shader-space" type="notjs">
      attribute vec2 a_position;
      uniform vec2 u_resolution;
      
      uniform vec2 u_position;
      uniform vec2 u_scale;
      varying vec2 v_rpos;

      void main() {
        vec2 clipSpace = a_position * 2.0 - 1.0;
        gl_Position = vec4(clipSpace * vec2(1, -1), 1, 1);
        v_rpos = (a_position - u_position / u_scale) * u_resolution / u_scale;
      }
    </script>

    <script id="fragment-shader-space" type="notjs">
      varying vec2 v_rpos;
      uniform sampler2D u_image;
      void main() {
        gl_FragColor = texture2D(u_image, v_rpos);
      }
    </script>

    <script id="vertex-shader-black-hole" type="notjs">
      attribute vec2 a_position;
      varying vec2 v_tpos;
      varying vec2 v_rpos;
      varying vec2 v_dpos;

      uniform vec2 u_resolution;
      
      uniform vec2 u_position;
      uniform vec2 u_scale;
      uniform float u_angle;

      uniform vec2 u_s_position;
      uniform vec2 u_s_scale;

      uniform float u_roll;

      void main() {
        vec2 rotation = vec2(sin(u_angle), cos(u_angle));
        vec2 rotated = vec2(
          a_position.x * rotation.y + a_position.y * rotation.x,
          a_position.y * rotation.y - a_position.x * rotation.x
        );
        vec2 position = rotated*u_scale + u_position;

        vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;
        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);

        v_tpos =  ( a_position*u_scale + u_position - u_s_position/u_s_scale*u_resolution ) / u_s_scale ;
        v_rpos = a_position;
        v_dpos = vec2(v_rpos.x, v_rpos.y/sin(u_roll));
      }
    </script>

    <script id="fragment-shader-black-hole" type="notjs">
      varying vec2 v_rpos;
      uniform sampler2D u_image;
      varying vec2 v_tpos;
      uniform float u_radius;

      void main() {
        float r = min(u_radius, 0.5);
        float d = length(v_rpos);
        float x = abs(pow(r-d/2., 2.))*sign(r-d/2.);

        if (d<u_radius-d) {
          gl_FragColor = vec4(vec3(0), smoothstep(0.0,0.01,u_radius/2.-d));
        } else if (x > 0.) {
          vec2 dispos = v_tpos - normalize(v_rpos)*x;
          gl_FragColor = texture2D(u_image, dispos);
        }
      }
    </script>

    <script id="fragment-shader-black-hole-accretion" type="notjs">
      varying vec2 v_rpos, v_dpos;
      uniform float u_frame;
      uniform float u_random;
      uniform float u_radius;
      uniform float u_bright;
      uniform float u_hue;

      vec4 noize = vec4(2,0.8,2.5,1);

      float size = u_radius;

      float v(float length, float angle) {
        float mask = smoothstep(1.,0.2,length) * smoothstep(u_radius/2.,u_radius/2.+0.3,length);
        return max((noize_harm(vec3(length+u_frame/10., cos(angle+u_frame)/20.+u_random, sin(angle+u_frame)/20.), noize)+1.)*mask+mask*u_bright, 0.);
      }

      void main() {
        float d = length(v_rpos);
        float x = u_radius-d;

        float a = atan(v_dpos.y, v_dpos.x);
        float speed = -cos(a);
        float val;

        vec3 color = hsl2rgb(vec3(u_hue+speed/20., 1, 0.5+speed/5.));
        if (d < 1. && (v_dpos.y > 0. || x<d)) {
          val = v(length(v_dpos*vec2(1, v_dpos.y > 0.?1.:(d-x)/d)), a);
          gl_FragColor += val*vec4(color, 1);
          if (x<d && v_dpos.y > 0.) {
            val = v(length(v_dpos*(d-x)/d)*2., -a);
            gl_FragColor += val*v_dpos.y*vec4(color, 0.3);
          }
        }
        gl_FragColor += pow((1.-abs(u_radius/2.-d)),60.)*vec4(color, 0.6);
        gl_FragColor += pow((1.-abs(u_radius/2.-d)),8.)*vec4(color, 0.2);
      }
    </script>

    <script id="vertex-shader-orbit" type="notjs">
      #define M_PI 3.1415926535897932384626433832795
      attribute vec2 a_position;
      uniform vec2 u_resolution;
      
      uniform vec2 u_position;
      uniform vec2 u_scale;
      
      varying vec2 v_rpos;

      void main() {
        vec2 position = a_position*u_scale + u_position;
        vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;
        gl_Position = vec4(clipSpace * vec2(1, -1), 0.9, 1);
        v_rpos = a_position;
      }
    </script>

    <script id="fragment-shader-orbit" type="notjs">
      varying vec2 v_rpos;

      uniform vec3 u_color;
      uniform float u_dashes;
      uniform float u_angle;
      uniform float u_speed;
      uniform int u_type;
      uniform vec2 u_scale;

      void main() {
        float a, b;
        float d = length(v_rpos);
        float angle = atan(v_rpos.y, v_rpos.x);

        if (u_type==1||u_type==3) {
          a = mod(angle-u_angle+M_PI*2., M_PI*2.)/(M_PI*2.);
          a = clamp(a-1.+u_speed, 0., 1.)*(1./u_speed);
        }
        if (u_type==2||u_type==3) {
          b = (cos(angle*u_dashes)+1.)*0.5;
          if (u_type==3) b*=0.2;
        }
        float w = .5/u_scale.x * max(1., a*1.5);
        float c = smoothstep(1.-3.*w,1.-w,d)*smoothstep(1.+3.*w,1.+w,d);

        gl_FragColor = vec4(u_color, (a+b)*c);
      }
    </script>

    <script id="fragment-shader-galaxy" type="notjs">
      varying vec2 v_rpos, v_dpos;
      uniform float u_random;
      uniform float u_spin;
      uniform float u_arms;
      uniform float u_opacity;
      uniform float u_perspective;
      uniform float u_bulge;
      uniform vec3 u_armscolor;
      uniform vec3 u_bulgecolor;
      uniform vec3 u_dustcolor;
      vec4 noize = vec4(.2,0.8,2.5,1);
      vec2 dposp;

      float spiral(float length, float angle, float x, float f) {
        angle += pow(length, .5) * f;
        float a = (sin((angle)*u_arms)+1.)/4.;
        float mask = smoothstep(1.,0.2,length) * smoothstep(0.0, 0.2, length);;
        float r1 = (noize_harm(vec3(dposp, x), noize)+1.)/2.;
        float elliptical = pow(1.-(length+0.2), 2.);
        return max(0., (r1*a+elliptical)*mask);
      }

      void main() {
        dposp = v_dpos * ((v_rpos.y/2.+.5)*u_perspective+1.);
        float d = length(dposp);
        float a = atan(dposp.y, dposp.x);
        float arms, bulge;

        if (d < 1.) {
          arms += pow(spiral(d, a+M_PI/2., u_random+0., u_spin), 5.);
          arms += spiral(d, a+M_PI/2., u_random+100., u_spin*0.6)/2.;
          arms += spiral(d, a+M_PI/5., u_random+200., u_spin*0.8)/4.;
        }

        vec2 bulgev = v_rpos * vec2(0.5, 0.5*u_bulge);
        bulge = pow(clamp(0.1-length(bulgev), 0., 1.), 1.)*10.;
        
        float bright = arms + bulge;
        float stars = N2(dposp+vec2(u_random, 0)) < bright*2. ? N2(dposp+vec2(u_random*2.+10., 0))+bright/2.:0.;
        float dust = pow(spiral(d, a+M_PI/5., u_random+300., u_spin*0.8),2.)/1.5;

        gl_FragColor = vec4(vec3(1.-d)+u_armscolor, clamp(arms, 0., 1.6));
        gl_FragColor = colormix(gl_FragColor, vec4(vec3(1.-d)+u_bulgecolor, clamp(bulge, 0., 1.6)));
        gl_FragColor += clamp(stars, 0., 1.)/5.;
        gl_FragColor = clamp(gl_FragColor, 0., 1.);
        gl_FragColor -= vec4((1.-u_dustcolor)*dust, 0);
        
        gl_FragColor.a *= u_opacity;
      }
    </script>

    <script>
      function Random(seed) {
        function xoshiro128ss(a, b, c, d) {
          return function() {
            var t = b << 9, r = a * 5; r = (r << 7 | r >>> 25) * 9;
            c ^= a; d ^= b;
            b ^= c; a ^= d; c ^= t;
            d = d << 11 | d >>> 21;
            return (r >>> 0) / 4294967296;
          }
        }
        function mulberry32(a) {
          return function() {
            var t = a += 0x6D2B79F5;
            t = Math.imul(t ^ t >>> 15, t | 1);
            t ^= t + Math.imul(t ^ t >>> 7, t | 61);
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
          }
        }
        function sfc32(a, b, c, d) {
          return function() {
            a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0;
            var t = (a + b) | 0;
            a = b ^ b >>> 9;
            b = c + (c << 3) | 0;
            c = (c << 21 | c >>> 11);
            d = d + 1 | 0;
            t = t + d | 0;
            c = c + t | 0;
            return (t >>> 0) / 4294967296;
          }
        }
        let h1 = 1779033703, h2 = 3144134277,
          h3 = 1013904242, h4 = 2773480762;
        for (let i = 0, k; i < seed.length; i++) {
          k = seed.charCodeAt(i);
          h1 = h2 ^ Math.imul(h1 ^ k, 597399067);
          h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);
          h3 = h4 ^ Math.imul(h3 ^ k, 951274213);
          h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);
        }
        h1 = Math.imul(h3 ^ (h1 >>> 18), 597399067);
        h2 = Math.imul(h4 ^ (h2 >>> 22), 2869860233);
        h3 = Math.imul(h1 ^ (h3 >>> 17), 951274213);
        h4 = Math.imul(h2 ^ (h4 >>> 19), 2716044179);
        this.seed = [(h1^h2^h3^h4)>>>0, (h2^h1)>>>0, (h3^h1)>>>0, (h4^h1)>>>0];
        this.rand = xoshiro128ss(this.seed[0], this.seed[1], this.seed[2], this.seed[3]);
        
        this.gauss_ready = false;
        this.gauss_second = 0.0;

        this.randS = function() {
          return `${this.rand()}`.replace('0\.', '');
        }
        this.gauss = function(mean, dev) {
          mean = mean == undefined ? 0.0 : mean;
          dev = dev == undefined ? 1.0 : dev;
          
          if (this.gauss_ready) {
            this.gauss_ready = false;
            return this.gauss_second * dev + mean;
          }
          else {
            var u, v, s;
            do {
              u = 2.0 * this.rand() - 1.0;
              v = 2.0 * this.rand() - 1.0;
              s = u * u + v * v;
            } while (s > 1.0 || s == 0.0);
            
            var r = Math.sqrt(-2.0 * Math.log(s) / s);
            this.gauss_second = r * u;
            this.gauss_ready = true;
            return r * v * dev + mean;
          }
        };
        this.range = function (min, max) {
          if (typeof(max) == 'undefined') {
            max = min; min = 0;
          }
          return min + this.rand() * (max - min);
        }
        this.choice = function (set) {
          return set[Math.floor(this.rand()*set.length)];
        }

        this.weighted_choice = function(set, weights) {
          let i;
          if (typeof(weights) == 'undefined')
            return this.choice(set);
          for (i = 1; i < weights.length; i++)
            weights[i] += weights[i - 1];
          let random = this.rand() * weights[weights.length - 1];
          for (i = 0; i < weights.length; i++)
            if (weights[i] > random)
              break;
          return set[i];
        }

        this.getValue = function(rule) {
          if (rule.set !== undefined) {
            return this.choice(rule.set);
          }
          if (rule.mean !== undefined || rule.dev !== undefined) {
            let value = this.gauss(rule.mean, rule.dev);
            if (rule.min !== undefined)
              value = Math.max(rule.min, value);
            if (rule.max !== undefined)
              value = Math.min(rule.max, value);
            return value;
          }
          if (rule.min !== undefined || rule.min !== undefined) {
            return this.range(rule.min, rule.max);
          }
          if (rule.value !== undefined) {
            return rule.value;
          }
          return rule;
        }
        this.roll = function(sets, weights) {
          let set;
          if (Array.isArray(sets)) {
            set = this.weighted_choice(sets, weights);// sets[Math.floor(this.rand() * sets.length)];
          }
          let value, params = {};
          for (let key in set) {
            if (Array.isArray(set[key])) {
              value = [];
              for (let sub in set[key]) {
                value.push(this.getValue(set[key][sub]));
              }
            } else {
              value = this.getValue(set[key]);
            }
            params[key] = value;
          }
          return params;
        }
      }

      class Program {
        static defines(text, params) {
          for (let param in params || []) {
            text = `#define ${param} ${params[param]}\n${text}`;
          }
          return text;
        }
        constructor(renderer, name, vsel, fsel, params) {
          this.renderer = renderer;
          const gl = this.gl = renderer.gl;
          const vertexShader = this.createShader(gl.VERTEX_SHADER, this.constructor.defines(document.querySelector(vsel).text, params));
          const fragmentShader = this.createShader(gl.FRAGMENT_SHADER, this.constructor.defines(document.querySelector("#fragment-shader-lib").text + document.querySelector(fsel).text, params));
          this.program = this.createProgram(vertexShader, fragmentShader);
          const positionAttributeLocation = gl.getAttribLocation(this.program, "a_position");

          gl.enableVertexAttribArray(positionAttributeLocation);
          gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
          
          this.use();
          gl.uniform2f(gl.getUniformLocation(this.program, "u_resolution"), gl.canvas.width, gl.canvas.height);
          this.setters = this.createUniformSetters();
          renderer.addProgram(name, this);
        }
        use() {
          this.renderer.gl.useProgram(this.program);
          this.renderer.program = this;
          return this;
        }
        /*
         * Copyright 2021 GFXFundamentals.
         * All rights reserved.
         *
         * Redistribution and use in source and binary forms, with or without
         * modification, are permitted provided that the following conditions are
         * met:
         *
         *     * Redistributions of source code must retain the above copyright
         * notice, this list of conditions and the following disclaimer.
         *     * Redistributions in binary form must reproduce the above
         * copyright notice, this list of conditions and the following disclaimer
         * in the documentation and/or other materials provided with the
         * distribution.
         *     * Neither the name of GFXFundamentals. nor the names of his
         * contributors may be used to endorse or promote products derived from
         * this software without specific prior written permission.
         *
         * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
         * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
         * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
         * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
         * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
         * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
         * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
         * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
         * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
         * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
         * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
         */
        createShader(type, source) {
          var shader = this.gl.createShader(type);
          this.gl.shaderSource(shader, source);
          this.gl.compileShader(shader);
          var success = this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS);
          if (success) {
            return shader;
          }

          console.log(this.gl.getShaderInfoLog(shader));
          this.gl.deleteShader(shader);
        }
        createProgram(vertexShader, fragmentShader) {
          var program = this.gl.createProgram();
          this.gl.attachShader(program, vertexShader);
          this.gl.attachShader(program, fragmentShader);
          this.gl.linkProgram(program);
          var success = this.gl.getProgramParameter(program, this.gl.LINK_STATUS);
          if (success) {
            return program;
          }
          console.log(this.gl.getProgramInfoLog(program));
          this.gl.deleteProgram(program);
        }
        createUniformSetters() {
          let textureUnit = 0;
          let program = this.program, gl = this.gl;
          function createUniformSetter(program, uniformInfo) {
            const location = gl.getUniformLocation(program, uniformInfo.name);
            const type = uniformInfo.type;
            // Check if this uniform is an array
            if (type === gl.FLOAT) {
              return function(v) {
                gl.uniform1f(location, v);
              };
            }
            if (type === gl.FLOAT_VEC2) {
              return function(v) {
                gl.uniform2fv(location, v);
              };
            }
            if (type === gl.FLOAT_VEC3) {
              return function(v) {
                gl.uniform3fv(location, v);
              };
            }
            if (type === gl.FLOAT_VEC4) {
              return function(v) {
                gl.uniform4fv(location, v);
              };
            }
            if (type === gl.INT) {
              return function(v) {
                gl.uniform1i(location, v);
              };
            }
            if (type === gl.SAMPLER_2D) {
              return function(bindPoint, unit) {
                return function(texture) {
                  gl.uniform1i(location, unit);
                  gl.activeTexture(gl.TEXTURE0 + unit);
                  gl.bindTexture(bindPoint, texture);
                };
              }(gl.TEXTURE_2D, textureUnit++);
            }
            throw ('unknown type: 0x' + type.toString(16)); // we should never get here.
          }

          const uniformSetters = { };
          const numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

          for (let ii = 0; ii < numUniforms; ++ii) {
            const uniformInfo = gl.getActiveUniform(program, ii);
            if (!uniformInfo) {
              break;
            }
            let name = uniformInfo.name;
            // remove the array suffix.
            if (name.substr(-3) === '[0]') {
              name = name.substr(0, name.length - 3);
            }
            const setter = createUniformSetter(program, uniformInfo);
            uniformSetters[name] = setter;
          }
          return uniformSetters;
        }
        setParams(params) {
          for (let key in params) {
            if (this.setters[`u_${key}`]) {
              this.setters[`u_${key}`](params[key]);
              // console.log(key, params[key]);
            }
          }
        }
      }

      class Renderer {
        constructor (canvas) {
          this.programs = {};
          this.positionslist = {};
          const gl = this.gl = canvas.getContext("webgl", {antialias: false, alpha:false}) || canvas.getContext('experimental-webgl');
          if (!gl) return;

          const positionBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
          this.createPositions('default', [-1,-1, 1,-1, -1,1, 1,1]);
          this.setPositions();
          gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
          gl.clearColor(0, 0, 0, 0);
          gl.clear(gl.COLOR_BUFFER_BIT);
          gl.enable(gl.BLEND);
          gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.SRC_ALPHA, gl.ONE);

          this.fb = gl.createFramebuffer();
          canvas.addEventListener('webglcontextlost', (event) => {
            window.location.reload();
          });
        }
        addProgram(name, program) {
          this.programs[name] = program;
          return program;
        }
        useProgram(name) {
          return this.programs[name].use();
        }
        createPositions(name, positions) {
          this.positionslist[name] = new Float32Array(positions);
        }
        setPositions(positions) {
          positions = this.positionslist[positions || 'default'];
          this.positions = positions;
          this.gl.bufferData(this.gl.ARRAY_BUFFER, positions, this.gl.STATIC_DRAW);
          this.count = Math.floor(positions.length/2);
        }
        clear() {
          this.gl.clear(this.gl.COLOR_BUFFER_BIT);
        }
        render(params, x, y, s, s1, a) {
          if (!this.program) return;
          if (typeof a == 'undefined') { a = s1; s1 = s;}
          this.program.setParams(Object.assign({position: [x, y], scale: [s || 1, s1 || s], angle: a || 0}, params));
          this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, this.count || 4);
        }
        texture(params, resolution, texParams) {
          const gl = this.gl;
          const targetTexture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, targetTexture);

          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, resolution, resolution, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
          let minFilter = texParams['MIN_FILTER'] || gl.LINEAR_MIPMAP_LINEAR;
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texParams['MAG_FILTER'] || gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, texParams['WRAP'] || gl.REPEAT);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, texParams['WRAP'] || gl.REPEAT);
          gl.bindFramebuffer(gl.FRAMEBUFFER, this.fb);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, targetTexture, 0);
          let box = {};
          for (let i=0; i<this.positions.length; ++i){
            if (!(i % 2)) {
              if (typeof(box.x1)=='undefined' || this.positions[i] < box.x1) box.x1 = this.positions[i];
              if (typeof(box.x2)=='undefined' || this.positions[i] > box.x2) box.x2 = this.positions[i];
            } else {
              if (typeof(box.y1)=='undefined' || this.positions[i] < box.y1) box.y1 = this.positions[i];
              if (typeof(box.y2)=='undefined' || this.positions[i] > box.y2) box.y2 = this.positions[i];
            }
          }
          box.w = box.x2-box.x1;
          box.h = box.y2-box.y1;
          gl.viewport(0, 0, resolution, resolution);
          gl.uniform2f(gl.getUniformLocation(this.program.program, "u_resolution"), resolution, resolution);
          this.render(params, resolution*(-box.x1/box.w), resolution*(-box.y1/box.h), resolution/box.w, resolution/box.h, 0);
          if (minFilter == gl.LINEAR_MIPMAP_LINEAR || minFilter == gl.LINEAR_MIPMAP_NEAREST || minFilter == gl.NEAREST_MIPMAP_LINEAR || minFilter == gl.LINEAR_MIPMAP_LINEAR) {
            gl.generateMipmap(gl.TEXTURE_2D);
          }
          gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          return targetTexture;
        }
        renderTo(texture, resolution, params, x, y, s, s1, a) {
          const gl = this.gl;
          if (typeof(resolution)!='object') resolution=[resolution, resolution];
          gl.bindFramebuffer(gl.FRAMEBUFFER, this.fb);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
          gl.viewport(0, 0, resolution[0], resolution[1]);
          gl.uniform2f(gl.getUniformLocation(this.program.program, "u_resolution"), resolution[0], resolution[1]);
          this.render(params, x, y, s, s1, a);
          gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
      }

      class Point {
        constructor (x, y) {
          this.set(x,y);
        }
        static fromPolar(a, r) {
          r = r || 1;
          return new Point(Math.cos(a) * r, Math.sin(a) * r);
        }
        static fromPos(x, y) {
          return new Point(x, y);
        }
        set (x, y) {
          if (x instanceof Point) {
            this.x=x.x;
            this.y=x.y;
          } else {
            this.x=x || 0;
            this.y=y || 0;
          }
          return this;
        }
        add (x, y) {
          if (!(x instanceof Point)) {
            return this.add(new Point(x,y));
          }
          this.x += x.x;
          this.y += x.y;
          return this;
        }
        sub (x, y) {
          if (!(x instanceof Point)) {
            return this.sub(new Point(x,y));
          }
          this.x -= x.x;
          this.y -= x.y;
          return this;
        }
        mul (x) {
          this.x *= x;
          this.y *= x;
          return this;
        }
        dot (x, y) {
          if (!(x instanceof Point)) {
            return this.dot(new Point(x,y));
          }
          return this.x*x.x + this.y*x.y;
        }
        len () {
          return Math.hypot(this.x, this.y);
        }
        ang () {
          return Math.atan2(this.y, this.x);
        }
        dist (x, y) {
          if (!(x instanceof Point)) {
            return this.dist(new Point(x,y));
          }
          return Math.hypot((x.x - this.x), (x.y - this.y));
        }
        rotate(a) {
          this.set(Point.fromPolar(this.ang()+a, this.len()));
        }
        norm () {
          let l = this.len();
          this.x /= l;
          this.y /= l;
          return this;
        }
        scaled(trans) {
          return (new Point(this)).mul(trans.scale).add(trans.pos);
        }
      }

      function hsl2rgb(h,s,l) {
        let a = s*Math.min(l,1-l);
        let f = (n,k=(n+h/30)%12) =>
            Math.trunc((l - a*Math.max(Math.min(k-3,9-k,1),-1))*255);
        return [f(0), f(8), f(4)];
      }

      function getParam(param) {
        params = new URLSearchParams(window.location.search);
        switch (param) {
          case 'population': return Math.max(10, 100 - (params.get('population') || 40));
          case 'id': return (window.location.hash?window.location.hash.substring(1):false) || params.get('id') || null;
        }
      }

      class Orbit {
        constructor(radius, angle, speed, rotationAngle, rotationSpeed) {
          this.radius = radius;
          this.angle = angle;
          this.speed = speed;
          this.rotationAngle = rotationAngle || 0;
          this.rotationSpeed = rotationSpeed || 0;
        }
        get x() { return Math.cos(this.angle) * this.radius; }
        get y() { return Math.sin(this.angle) * this.radius; }
        get pos() { return new Point(this.x, this.y); }
        move() {
          this.angle += this.speed;
          this.rotationAngle -= this.rotationSpeed;
        }
      }
      class CelestialBody {
        constructor(random, parent, mass, radius, orbit) {
          this.params = {};
          this.seed = random instanceof Random ? `${random.randS()}` : random;
          this.random = new Random(this.seed);
          this.parent = parent;
          this.mass = mass;
          this.radius = radius;
          this.orbit = orbit;
          this.satelites = [];
          if (this.parent) {
            this.parent.addSatelite(this);
          }
        }
        roll(){
          if (this.sets)
            this.params = this.random.roll(this.sets, this.weights);
          this.params.random = this.random.rand()*1110;
        }
        get x() { return this.parent ? this.parent.x + this.orbit.x : 0; }
        get y() { return this.parent ? this.parent.y + this.orbit.y : 0; }
        get pos() { return new Point(this.x, this.y); }
        systemParent() {
          if (!this.parent) return this;
          return this.parent.systemParent();
        }
        eachSatelite(f, ...args) {
          f.apply(this, args);
          for (let i=0; i<this.satelites.length; ++i)
            this.satelites[i].eachSatelite(f, ...args);
        }
        moveOne() { this.orbit.move() }
        move() {
          for (let i=0; i<this.satelites.length; ++i)
            this.satelites[i].move();
          this.moveOne();
        }
        gravitateOne(obj) {
          const G = 100;
          let dist = Math.max((this.pos.dist(obj.pos)), this.radius, 100);
          let f = (this.mass / dist**2) * G;
          obj.gdp.add (Point.fromPos(obj.pos).sub(this.pos).norm().mul(f));
        }
        gravitate(obj) {
          for (let i=0; i<this.satelites.length; ++i)
            this.satelites[i].gravitate(obj);
          this.gravitateOne(obj);
        }
        collisionOne(obj) {
          if (obj.land) {
            let dp = Point.fromPos(obj.pos).sub(this.pos);
            if (dp.len() < this.radius + (obj.r || 0)) {
              return obj.land(this, dp);
            }
          }
        }
        collision(obj) {
          for (let i=0; i<this.satelites.length; ++i)
            if (this.satelites[i].collision(obj)) return;
          this.collisionOne(obj);
        }
        addSatelite(satelite) {
          this.satelites.push(satelite);
        }
        populate(population) {
          population = population || 50;
          let n = Math.floor(this.random.range(this.radius/population))-2;
          let or = this.radius*2 + this.radius/10;
          let r, d;
          n = Math.max(0, n);
          if (!this.parent) n = Math.max(n, 6);

          let asteroidProb = (!this.parent) * 0.5;

          for (let i=0; i<n; ++i) {
            r = this.random.range(10, this.radius/2);
            d = this.random.range(or-200, or+200);
            or = d + r*2;

            if (this.random.rand() < asteroidProb) {
              n++;
              const orbit = new Orbit(
                d,
                this.random.range(Math.PI*2),
                this.random.gauss(0.001, 0.0005),
                this.random.range(Math.PI*2),
                this.random.gauss(0, 3) * 0
              );
              new AsteroidBelt(this, orbit);
              asteroidProb = asteroidProb * asteroidProb;
            } else {
              const orbit = new Orbit(
                d,
                this.random.range(Math.PI*2),
                Math.sqrt((this.radius+r)/(d**2))/3,
                this.random.range(Math.PI*2),
                this.random.range(0.3, Math.PI*2)/300
              );
              const planet = new Planet(this, 4/3*Math.PI*r, r, orbit);
              planet.populate(population);
            }
          }
        }
        drawOne(trans) {
          if (this.program) {
            let scaledPos = this.pos.scaled(trans);
            this.program.use().renderer.render(
              this.params,
              scaledPos.x,
              scaledPos.y,
              this.radius*trans.scale,
              this.radius*trans.scale,
              this.rotation || 0
            );
          }
          if (window.mr && window.mr.man && window.mr.man.onPlanet == this)
            window.mr.drawMan();
        }
        draw(trans) {
          this.drawOne(trans);
          for (let i=0; i<this.satelites.length; ++i)
            this.satelites[i].draw(trans);
        }
      }
      class Planet extends CelestialBody {
        sets = [
          { // earth
            type: 0,
            coloring: 1,
            jpfactor: 10,
            heightmap: [10, 0.6, 2.5, 0.8],
            groundcolor: [0.1, 0.8, 0.1],
            groundcolor2: [1.41, 0.24, 0.33],
            seacolor: [0.0, {min:0.2, max: 0.4}, 1],
            moisturemap: [10, 0.6, 2.5, 1],
            waterlevel: 0.5,
            grain: [0.5, 0.2],
            clouds: [1, 1, 2.5, {mean: 0.8, dev: 0.5,}],
            wind: {min:1.05, max: 1.25},
            cloudy: {mean: 0.4, dev: 0.1,},
            cloudchange: 0.05,
            climate: [2, 0],
            lightambient: 0.2,
            seashine: {mean: 0.3, dev: 0.3, min:0, max:0.8},
            albedo: {mean: 0.5, dev: 0.1, min: 0.1},
            glow: 3,
            atmosphere: 1,
            craters: {mean: 0.0, dev: 0.1,},
            bumpy: {mean: 2, dev: 0.5,},
          },
          { // jupiter
            type: 2,
            coloring: 0,
            jpfactor: {
              mean: 10, dev: 1,
            },
            heightmap: [
              {mean: 20, dev: 5, min: 10},
              {mean: 0.2, dev: 0.2,},
              {mean: 1.5, dev: 0.2,},
              {mean: 1, dev: 0.01,},
            ],
            groundcolor: [
              {min: 0, max: 2,},
              {min: 0, max: 2,},
              {min: 0, max: 2,},
            ],
            groundcolor2: [
              {min: 0, max: 2,},
              {min: 0, max: 2,},
              {min: 0, max: 2,},
            ],
            seacolor: [
              {min: 0, max: 2,},
              {min: 0, max: 2,},
              {min: 0, max: 2,},
            ],
            moisturemap: [
              {mean: 10, dev: 5,},
              {mean: 0.5, dev: 0.1,},
              {mean: 2.5, dev: 0.2,},
              {value: 1,},
            ],
            grain: [{mean: 0.7, dev: 0.3,}, {min: 0, max: 0.5,}],
            clouds: [
              {mean: 4, dev: 1,},
              {min: 0.8, max: 1.1},
              {mean: 2.5, dev: 0.3,},
              {mean: 0.9, dev: 0.5,},
            ],
            wind: {
              min:1, max: 1.4,
            },
            cloudy: {
              mean: 0.5, dev: 0.1,
            },
            cloudchange: {
              mean: 0.05, dev: 0.001, min: 0,
            },
            climate: [
              {mean: 2, dev: 0.3, min: 0},
              {value: 0,},
            ],
            lightambient: {
              mean: 0.2, dev: 0.1, min: 0.01,
            },
            seashine: {
              mean: 1, dev: 0.5,
            },
            albedo: {
              mean: 0.5, dev: 0.1, min: 0.1,
            },
            glow: {
              mean: 2.5, dev: 3, max: 5
            },
            atmosphere: 1,
            craters: -1,
            bumpy: 0,
          },
          { // lava
            type: {'set':[0,1,2]},
            coloring: 2,
            jpfactor: 10,
            heightmap: [10, 0.6, 2.5, 0.8],
            groundcolor: [
              {min: 0, max: 2,},
              {min: 0, max: 2,},
              {min: 0, max: 2,},
            ],
            groundcolor2: [
              {min: 0, max: 2,},
              {min: 0, max: 2,},
              {min: 0, max: 2,},
            ],
            seacolor: [
              {min: 1.5, max: 2,},
              {min: 0, max: 2,},
              {min: 0, max: 0.2,},
            ],
            moisturemap: [
              {mean: 10, dev: 5,},
              {mean: 0.5, dev: 0.1,},
              {mean: 2.5, dev: 0.2,},
              {value: 1,},
            ],
            waterlevel: {min:0.2, max: 0.3},
            grain: [0.5, 0.4],
            clouds: [3, 0.9, 2.5, {mean: 0.9, dev: 0.5,}],
            wind: {min:1.05, max: 1.25},
            cloudy: 0.4,
            cloudchange: 0.05,
            climate: [3, 0],
            lightambient: 0.2,
            seashine: {mean: 0.3, dev: 0.3, min:0, max:0.8},
            albedo: {mean: 0.5, dev: 0.1, min: 0.1},
            glow: 3,
            atmosphere: {'set':[0,0,1]},
            craters: {mean: 0, dev: 0.5,},
            bumpy: {mean: 2, dev: 0.5,},
          },
          {
            type: {
              'set': [0,1],
            },
            coloring: {
              'set': [0,1],
            },
            jpfactor: {
              mean: 10, dev: 20,
            },
            heightmap: [
              {mean: 20, dev: 10, min: 1},
              {mean: 0.6, dev: 0.1,},
              {mean: 2.5, dev: 0.2,},
              {mean: 1, dev: 0.01,},
            ],
            groundcolor: [
              {min: 0, max: 2,},
              {min: 0, max: 2,},
              {min: 0, max: 2,},
            ],
            groundcolor2: [
              {min: 0, max: 2,},
              {min: 0, max: 2,},
              {min: 0, max: 2,},
            ],
            seacolor: [
              {min: 0, max: 2,},
              {min: 0, max: 2,},
              {min: 0, max: 2,},
            ],
            moisturemap: [
              {mean: 10, dev: 5,},
              {mean: 0.5, dev: 0.1,},
              {mean: 2.5, dev: 0.2,},
              {value: 1,},
            ],
            waterlevel: {min:0.2, max: 0.6},
            grain: [{min: 0, max: 1,}, {min: 0, max: 0.5,}],
            clouds: [
              {mean: 3, dev: 1,},
              {min: 0.8, max: 1.1},
              {mean: 2.5, dev: 0.3,},
              {mean: 1.0, dev: 1.3,},
            ],
            wind: {
              min: 1, max: 1.4
            },
            cloudy: {
              mean: 0.5, dev: 0.1,
            },
            cloudchange: {
              mean: 0.05, dev: 0.001, min: 0,
            },
            climate: [
              {mean: 2, dev: 0.3, min: 0},
              {value: 0,},
            ],
            lightambient: {
              mean: 0.2, dev: 0.1, min: 0.01,
            },
            seashine: {mean: 0.3, dev: 0.3, min:0, max:0.8},
            albedo: {
              mean: 0.5, dev: 0.1, min: 0.1,
            },
            glow: {
              mean: 2.5, dev: 3, max: 5
            },
            atmosphere: {'set': [1,1,0]},
            craters: {min: -0.3, max: 0.95,},
            bumpy: {mean: 2, dev: 1,},
          },
        ];
        weights = [0.5, 0.5, 0.1, 1];
//        weights = [0, 0., 1, 0];
        drawOrbit=true;
        constructor(parent, mass, radius, orbit) {
          super(parent.random, parent, mass, radius, orbit);
          this.roll();
          this.params.lightcolor = [1, 1, 1];
          this.params.albedo = 1;
          this.rotation = this.random.range(Math.PI*2);
          this.orbitColor = this.params.groundcolor;
          this.generateTex();
          if (this.random.rand() < 0.3 && radius > 100) {
            this.generateRings();
          }
        }
        roll(){
          super.roll();
          this.params.lightcolor = this.systemParent().light;
          this.program = window.renderer.programs[`planet${this.params.atmosphere}${this.params.coloring}`];
        }
        drawOne(trans) {
          let a = Point.fromPos(this.pos).sub(this.systemParent().pos).ang() + Math.PI;
          let s = Point.fromPolar(a + this.rotation, 1);
          this.params.lightdirection = [s.x, s.y, 1];
          this.params.lightcolor = this.systemParent().light;
          this.params.rotation = this.orbit.rotationAngle;
          //this.program = window.renderer.programs['planet'];
          //super.drawOne(trans);
          let scaledPos = this.pos.scaled(trans);

          if (this.rings) {
            window.renderer.programs['rings'].use().renderer.render(
              Object.assign(this.rings, {bf:-1}),
              scaledPos.x,
              scaledPos.y,
              this.radius*this.rings.size*trans.scale,
              this.radius*this.rings.size*this.rings.exc*trans.scale,
              this.rotation
            );
          }

          this.program.use().renderer.render(
            this.params,
            scaledPos.x,
            scaledPos.y,
            this.radius*trans.scale,
            this.radius*trans.scale,
            this.rotation || 0
          );

          if (window.mr && window.mr.man && window.mr.man.onPlanet == this)
            window.mr.drawMan();

          if (this.rings) {
            window.renderer.programs['rings'].use().renderer.render(
              Object.assign(this.rings, {bf:1}),
              scaledPos.x,
              scaledPos.y,
              this.radius*this.rings.size*trans.scale,
              this.radius*this.rings.size*this.rings.exc*trans.scale,
              this.rotation
            );
          }
        }
        generateRings() {
          let r1 = this.random.range(1.1, 2);
          let r2 = r1 + this.random.range(0.5, 2);
          let luminocity = this.random.range(0.5, 0.8);
          this.rings = {
            exc: this.random.range(0.05, 0.2),
            size: r2,
            innerradius: r1/r2,
            random: this.random.rand()*1000,
            color: [luminocity+this.random.gauss(0.2, 0.1), luminocity+this.random.gauss(0.2, 0.1), luminocity+this.random.gauss(0.2, 0.1)],
            transparency: this.random.range(0.1, 0.2),
          };
          window.renderer.useProgram('rings-texture');
          this.rings.image = window.renderer.texture(this.rings, 1024, {MIN_FILTER: window.renderer.gl.LINEAR_MIPMAP_LINEAR});
        }
        generateTex() {
          window.renderer.useProgram('planet-texture');
          window.renderer.setPositions('planet-texture');
          this.params.image = window.renderer.texture(this.params, 512, {MIN_FILTER: window.renderer.gl.LINEAR});
          if (this.params.atmosphere) {
            window.renderer.useProgram('planet-cloudmap');
            this.params.cloudmap = window.renderer.texture(this.params, 512, {MIN_FILTER: window.renderer.gl.LINEAR});
          }else {
            this.params.cloudmap = null;
          }
          window.renderer.setPositions();
          if (this.params.coloring == 2) {
            window.renderer.useProgram('planet-lava-glow');
            this.params.image = window.renderer.texture(this.params, 512, {MIN_FILTER: window.renderer.gl.LINEAR});
          }
          if (this.params.bumpy > 0) {
            window.renderer.useProgram('planet-normalmap');
            this.params.bump = window.renderer.texture(this.params, 512, {MIN_FILTER: window.renderer.gl.LINEAR});
          } else {
            this.params.bump = null;
          }
        }
      }
      class Sun extends CelestialBody {
        sets = [
          {
            shiny: [{min: 0.2, max: 3.5,}, {min: 0.01, max: 1.2,}],
            hue: {min:0, max: 60},
            rays: [{mean:0.7, dev:0.3, min:0.2},{mean:0.4, dev:0.1},{min:2, max:10},1],
          },
          {
            shiny: [{min: 0.2, max: 3.5,}, {min: 0.01, max: 1.2,}],
            hue: {min:160, max: 180},
            rays: [{mean:0.7, dev:0.3, min:0.2},{mean:0.4, dev:0.1},{min:2, max:10},1],
          },
        ];
        constructor(random, mass, radius) {
          super(
            random,
            null,
            mass,
            radius,
            new Orbit(0, 0, 0, 0, random.range(Math.PI / 50))
          );
          this.roll();
          this.program = window.renderer.programs.sun;
        }
        roll() {
          super.roll();
          let c = hsl2rgb(this.params.hue, 1, 0.8);
          c = [c[0]/255, c[1]/255, c[2]/255];
          let light = hsl2rgb(this.params.hue, 1, this.random.range(0.7, 0.9));
          light = [light[0]/255, light[1]/255, light[2]/255];
          this.light = light;
          this.params.color = c;
        }
        drawOne(trans) {
          this.params.rotation = this.orbit.rotationAngle;
          super.drawOne(trans);
        }
      }
      class BlackHole extends CelestialBody {
        sets = [
          {
            roll: {min:Math.PI/15, max: Math.PI/5},
            radius: {min:0.2, max: 0.8},
            brightness: {min:1, max: 3},
            hue: 0.1,
          },
        ];
        constructor(random, mass, radius) {
          super(
            random,
            null,
            mass,
            radius,
            new Orbit(0, random.range(Math.PI), random.range(Math.PI / 20, Math.PI / 40), 0, -random.range(Math.PI / 20, Math.PI / 40))
          );
          this.originalRadius = radius;
          this.roll();
        }
        roll() {
          super.roll();
          let light = hsl2rgb(this.params.hue*255, 1, this.random.range(0.7, 0.9));
          this.light = [light[0]/255, light[1]/255, light[2]/255];
          this.accretion = true;
        }
        drawOne(trans) {
          this.params.frame = this.orbit.rotationAngle;
          this.rotation = this.orbit.angle;
          //this.params.roll = Math.sin(this.orbit.rotationAngle/10)/2.;
          let scaledPos = this.pos.scaled(trans);
          let radius = Math.min(this.radius/this.params.radius, 1500);
          if (this.accretion) {
            window.renderer.programs['black-hole-accretion'].use().renderer.render(
              this.params,
              scaledPos.x, scaledPos.y,
              radius*trans.scale, radius*trans.scale,
              0
            );
          }
        }
      }
      class AsteroidBelt extends CelestialBody {
        sets = [
          {
            n: {mean: 250, dev: 100},
            width: {mean: 100, dev: 20},
            size: {mean: 15, dev: 5},
          }
        ];
        constructor(parent, orbit) {
          super(parent.random, parent, 0, 0, new Orbit(0, 0, 0));
          this.roll();
          for (let i=0; i<this.params.n; ++i) {
            new Asteroid(
                this,
                this.random.gauss(this.params.size, this.params.size/3),
                orbit.radius,
                orbit.speed,
                this.params.width,
              );
          }
        }
        gravitateOne(obj) {
          return;
        }
        collisionOne(obj) {
          return;
        }
      }
      class Asteroid extends CelestialBody {
        sets = [
          {
            lightambient: {min:0.1, max:0.3},
            rough: {min:0.1, max:0.8},
            luminocity: {min:0.2, max:0.5}
          },
        ];
        constructor(parent, radius, orbitRadius, speed, orbitWidth) {
          super(parent.random, parent, 0, radius, null);
          this.orbit = new Orbit(
            orbitRadius+this.random.gauss(0, orbitWidth/2),
            this.random.range(Math.PI*2),
            speed + this.random.range(Math.PI*2) / 10000,
            this.random.range(Math.PI*2),
            this.random.range(Math.PI*2) / 50,
          )
          this.roll();
          this.generateTex();
          this.program = window.renderer.programs.asteroid;
        }
        roll() {
          super.roll();
          this.params.color = [
            this.params.luminocity+this.random.gauss(0.1, 0.05),
            this.params.luminocity+this.random.gauss(0.1, 0.05),
            this.params.luminocity+this.random.gauss(0.1, 0.05)
          ];
        }
        drawOne(trans) {
          let a = Point.fromPos(this.pos).sub(this.systemParent().pos).ang() + Math.PI;
          let s = Point.fromPolar(a + this.orbit.rotationAngle, 1);
          this.params.lightdirection = [s.x, s.y, 1];
          this.rotation = this.orbit.rotationAngle;
          super.drawOne(trans);
        }
        generateTex() {
          window.renderer.useProgram('asteroid-texture');
          this.params.image = window.renderer.texture(this.params, 128, {MIN_FILTER: window.renderer.gl.LINEAR});
        }
        gravitateOne(obj) {
          return;
        }
        collisionOne(obj) {
          return;
        }
      }

      class Man {
        constructor(pos) {
          this.pos = new Point(pos);
          this.a = 0;
          this.s = 0;
          this.r = 100;
          this.dp = new Point();
          this.gdp = new Point();
          this.f = new Point();
          this.fuel = 100;
          this.thrust = {
            u0: 0.1,
            d0: 0.1,
            l0: 0.1,
            r0: 0.1,
            du: 0.05,
            dd: 0.1,
            dl: 0.1,
            dr: 0.1,
            get on() { return !!(this.u || this.d || this.l || this.r) },
            set u(x) { if(!!x!=!!this.u)this._u = x?this.u0:false; },
            set d(x) { if(!!x!=!!this.d)this._d = x?this.d0:false; },
            set l(x) { if(!!x!=!!this.l)this._l = x?this.l0:false; },
            set r(x) { if(!!x!=!!this.r)this._r = x?this.r0:false; },
            get u() { return this._u; },
            get d() { return this._d; },
            get l() { return this._l; },
            get r() { return this._r; },
            move() {
              if (this._u)this._u = Math.min(1, this._u+this.du);
              if (this._d)this._d = Math.min(1, this._d+this.dd);
              if (this._l)this._l = Math.min(1, this._l+this.dl);
              if (this._r)this._r = Math.min(1, this._r+this.dr);
            }
          }
          this.sets = [
            {
              color: [0.7, 0.7, 0.7],
              wide: {mean:0.33, dev:0.02,},
              curvy: {mean:0.8, dev:0.1},
              wing1: [{mean:0.7, dev:0.1}, {mean:-0.9, dev:0.1, min:-1}],
              wing1start: {min:-0.4, max:0.2},
              wing1end: -0.9,
              wing2: [{mean:0.5, dev:0.1},{mean:0, dev:0.1}],
              wing2start: {mean:0.6, dev:0.1},
              wingtipspos: {mean:0.9, dev:0.2},
              wingtipslength: {mean:0.5, dev:0.1},
              cockpit: [0.1, {mean:0.4, dev:0.05}],
              cockpitpos: [0, {mean:-0.3, dev:0.1}],
              cockpitwidth: {mean:1.2, dev:0.2, min:1},
              cockpitcolor: [0.2, 0.7, 1],
              ring1: {mean:0.4, dev:0.2},
              ring2: {mean:0.8, dev:0.1},
              ringscolor: [1, 0.5, 0.5],
            },
          ];
          this.params = random.roll(this.sets);
          this.params.wing1end = random.range(-1, this.params.wing1start-0.39);
          this.params.ring3 = this.params.ring2+random.range(0.01, 0.05);
          if (this.params.wingtipspos > 0.99)this.params.wingtipspos=0;
          this.frame = 0;
        }

        land(planet, dp){
          if (planet instanceof Planet/* || planet instanceof Sun || planet instanceof BlackHole*/) {
            if (this.takingOff) {
              this.stillTakingOff = true;
              return true;
            }
            this.onPlanet = planet;
            this.onPlanetA = dp.ang();

            mr.manNewPos = false;
            this.thrust.u = false;
            this.thrust.r = false;
            this.thrust.l = false;
            return true;
          }
        }

        move(sun) {
          this.frame++;
          this.gdp.set(0, 0);
          let oldPos = Point.fromPos(this.pos);

          if (window.hideMan) {
            const speed = 1000;
            this.pos.sub((this.thrust.l||0-this.thrust.r||0)*speed, (this.thrust.u||0-this.thrust.d||0)*speed);
            return;
          }

          //sun.eachSatelite(function(obj) {this.gravitate(obj)}, this);
          sun.gravitate(this);

          this.dp.add(this.gdp);

          // let objScaledPos = this.pos.scaled(mr.trans);
          // let forceScaledPos = Point.fromPos(this.pos).add(new Point(this.gdp).mul(-10000)).scaled(mr.trans);
          // mr.ctx.strokeStyle = '#f00';
          // mr.ctx.lineWidth=2;
          // mr.ctx.setLineDash([]);
          // mr.ctx.beginPath();
          // mr.ctx.moveTo(objScaledPos.x, objScaledPos.y);
          // mr.ctx.lineTo(forceScaledPos.x, forceScaledPos.y);
          // mr.ctx.stroke();

          let wasOnPlanet = this.onPlanet;

          this.stillTakingOff = false;
          if (!this.onPlanet) {
            sun.collision(this);
          }
          if (!this.stillTakingOff) {
            this.takingOff = false;
          }

          let sp=1;
          let ts = 1;
          if (mr.manNewPos) {
            let mod = (a, n) => (a % n + n) % n;
            let diff = new Point(mr.manNewPos.pos).sub(this.pos)
            let ga = diff.ang();
            let da = mod((ga - this.a + Math.PI), Math.PI*2) - Math.PI;
            
            if (diff.len() < 5000)ts += (diff.len()-5000)/5000;
            if(!this.takingOff && !this.onPlanet) {
              if (da < 0){this.thrust.l = true;this.thrust.r=false;}
              if (da > 0){this.thrust.r = true;this.thrust.l=false;}
            }
            this.thrust.u = true;
                           
            if (diff.len() < 2000)sp = 0.5;
            if (diff.len() < this.r+(mr.manNewPos.radius || 200)) {
              mr.manNewPos = false;
              this.thrust.u = false;
              this.thrust.r = false;
              this.thrust.l = false;
            }
          }

          if (!this.thrust.on) {
            this.takingOff = false;
          }

          if (this.takingOff) {
            if (this.pos.dist(this.takingOff.pos)<this.takingOff.radius) {
              this.onPlanetA = Point.fromPos(this.pos).sub(this.takingOff.pos).ang();
              this.pos = Point.fromPolar(this.onPlanetA, this.takingOff.radius).add(this.takingOff.pos);
            }

          }

          if (!wasOnPlanet && this.onPlanet) {
            this.thrust.u = false;
            // this.a = this.onPlanetA;
          }

          if (this.thrust.u && this.onPlanet) {
            this.takingOff = this.onPlanet;
            this.onPlanet = false;
          }

          if (!this.onPlanet) {
            if (this.thrust.u) {
              this.dp.sub(Point.fromPolar(this.a, 5*this.thrust.u*sp));
              this.fuel -= 1;
            }
            if (this.thrust.d) {
              this.dp.add(Point.fromPolar(this.a, 2.5*this.thrust.d));
              this.fuel -= 0.5;
            }
            if (this.thrust.r) {
              this.a += (0.05*this.thrust.r)/this.thrust.planetary;
              this.fuel -= 0.01;
            }
            if (this.thrust.l) {
              this.a -= (0.05*this.thrust.l)/this.thrust.planetary;
              this.fuel -= 0.01;
            }
            if (this.thrust.planetary > 1)
              this.thrust.planetary--;
          }

          if (this.onPlanet) {
            this.thrust.planetary = 10;
            let forA = Math.max(this.onPlanet.radius, 200);
            let o = Point.fromPolar(this.onPlanetA, this.onPlanet.radius);
            let moved = false;

            // if (this.onPlanet.rotation) {
            //   this.onPlanetA += this.onPlanet.rotation;
            //   moved = true;
            // }
            if (this.thrust.r) {
              this.onPlanetA += 10/forA;
              moved = true;
            }
            if (this.thrust.l) {
              this.onPlanetA -= 10/forA;
              moved = true;
            }

            let n = Point.fromPolar(this.onPlanetA, this.onPlanet.radius);
            let newPos = Point.fromPos(this.onPlanet.pos).add(n);
            this.dp = Point.fromPos(oldPos).sub(newPos);
            this.gdp = Point.fromPolar(this.onPlanetA);
            
              // this.a = this.onPlanetA;

            if (this.mode == 'man') {
              if (moved) {
                this.a = Point.fromPos(n).sub(o).ang();
              } else {
                // this.a += this.onPlanet.s;
              }
            } else {
              //this.a = this.onPlanetA;
              if (!moved) {
                let mod = (a, n) => (a % n + n) % n;
                let ga = this.onPlanetA;
                let da = mod((ga - this.a + Math.PI), Math.PI*2) - Math.PI;
                this.a += da/15;
              } else {
                this.a = this.onPlanetA;
              }
            }
          }

          let speed = this.dp.len();
          if (speed > 20) {
            this.dp.mul(0.95);
          }

          if (!this.thrust.on && !this.onPlanet) {
            let mod = (a, n) => (a % n + n) % n;
            let ga = this.gdp.ang();
            if (this.pos.len() > 10000)
              ga += Math.PI;
            let da = mod((ga - this.a + Math.PI), Math.PI*2) - Math.PI;
            this.a += da/150;
          }

          this.pos.sub(this.dp);
          this.thrust.move();
        }

        fireRocket(world) {
          const rocket = new Rocket(Point.fromPos(this.pos).add(Point.fromPolar(this.a, 100)), this.a+Math.PI, 0.44, 100);
          rocket.dp.set(this.dp);
          world.rockets.add(rocket);
        }
      };

      class Rocket{
        constructor(pos,a,s,fuel) {
          this.pos = new Point(pos);
          this.a=a;
          this.s=s;
          this.fuel=fuel || 40;
          this.dp = new Point();
          this.gdp = new Point();
          this.params = {
            color: [0.7, 0.7, 0.7],
            wide: 0.33,
            curvy: 0.5,
            wing1: [0.6,-0.8],
            wing1start: -0.4,
            wing1end: -1,
            wing2: [0,1],
            wing2start: 0,
            wingtipspos: 0,
            wingtipslength: 0,
            cockpit: [0.1, 0.1],
            cockpitpos: [0, -10],
            cockpitwidth: 0,
            cockpitcolor: [0.2, 0.7, 1],
            ring1: 0.34,
            ring2: 0.40,
            ring3: 0.46,
            ringscolor: [1, 0, 0],
          };
        }
        land(planet, dp){
          this.onPlanet = planet;
          this.onPlanetA = dp.ang();
          return true;
        }
        move(sun) {
          this.gdp.set(0, 0);

          sun.gravitate(this);
          
          if (this.fuel > 0) {
            this.dp.add(Point.fromPolar(this.a, this.s));
            this.fuel--;
          }
          this.dp.add(this.gdp);
          
          // let speed = this.dp.len();
          // if (speed > 20) {
          //   this.dp.mul(0.9);
          // }
          this.pos.sub(this.dp);
          sun.collision(this);
        }
      }

      MovingRect = function(canvas) {
        this.canvas = canvas;

        if (canvas.getContext) {
          this.width = this.canvas.getBoundingClientRect().width;
          this.height = this.canvas.getBoundingClientRect().height;

          const renderer = new Renderer(this.canvas);

          new Program(renderer, "orbit", "#vertex-shader-orbit", "#fragment-shader-orbit");
          new Program(renderer, "fill", "#vertex-shader-2d", "#fragment-shader-fill");

          new Program(renderer, "sun", "#vertex-shader-2d", "#fragment-shader-sun");
          new Program(renderer, "rocket", "#vertex-shader-rings", "#fragment-shader-rocket");
          new Program(renderer, "flame", "#vertex-shader-rings", "#fragment-shader-flame");

          new Program(renderer, "asteroid-texture", "#vertex-shader-2d", "#fragment-shader-asteroid-texture");
          new Program(renderer, "asteroid", "#vertex-shader-2d", "#fragment-shader-asteroid");

          new Program(renderer, "planet-texture", "#vertex-shader-2d", "#fragment-shader-planet-texture");
          new Program(renderer, "planet-lava-glow", "#vertex-shader-space", "#fragment-shader-planet-lava-glow");
          new Program(renderer, "planet-normalmap", "#vertex-shader-space", "#fragment-shader-normalmap");
          new Program(renderer, "planet-cloudmap", "#vertex-shader-2d", "#fragment-shader-cloudmap");
          new Program(renderer, "planet00", "#vertex-shader-2d", "#fragment-shader-planet", {COLORING: 0, ATMOSPHERE: 0});
          new Program(renderer, "planet01", "#vertex-shader-2d", "#fragment-shader-planet", {COLORING: 1, ATMOSPHERE: 0});
          new Program(renderer, "planet02", "#vertex-shader-2d", "#fragment-shader-planet", {COLORING: 2, ATMOSPHERE: 0});
          new Program(renderer, "planet10", "#vertex-shader-2d", "#fragment-shader-planet", {COLORING: 0, ATMOSPHERE: 1});
          new Program(renderer, "planet11", "#vertex-shader-2d", "#fragment-shader-planet", {COLORING: 1, ATMOSPHERE: 1});
          new Program(renderer, "planet12", "#vertex-shader-2d", "#fragment-shader-planet", {COLORING: 2, ATMOSPHERE: 1});

          new Program(renderer, "rings-texture", "#vertex-shader-2d", "#fragment-shader-rings-texture");
          new Program(renderer, "rings", "#vertex-shader-rings", "#fragment-shader-rings");

          new Program(renderer, "space-texture", "#vertex-shader-2d", "#fragment-shader-space-texture", {OVEREXPOSURE: 0.9});
          new Program(renderer, "space", "#vertex-shader-space", "#fragment-shader-space");

          new Program(renderer, "black-hole-accretion", "#vertex-shader-black-hole", "#fragment-shader-black-hole-accretion");
          new Program(renderer, "black-hole", "#vertex-shader-black-hole", "#fragment-shader-black-hole");

          new Program(renderer, "galaxy", "#vertex-shader-black-hole", "#fragment-shader-galaxy");

          const orbitPositions = [];
          const w = 0.01, w2 = 1-w, w1 = 1+w;
          for (let i=0; i<Math.PI*2; i+=Math.PI*2/100) {
            orbitPositions.push(Math.cos(i)*w1);
            orbitPositions.push(Math.sin(i)*w1);
            orbitPositions.push(Math.cos(i)*w2);
            orbitPositions.push(Math.sin(i)*w2);
          }
          renderer.createPositions('orbit', orbitPositions);
          renderer.createPositions('planet-texture', [0,0, 4,0, 0,2, 4,2]);
          renderer.createPositions('flame', [-1,0, 1,0, -1,2, 1,2]);

          window.renderer = renderer;

          this.setRandom(getParam('id'));
          this.genarateStars();
          this.genaratePlanets();

          console.log(this.sun);

          this.rockets = new Set();

          this.trans={
            pos: new Point(),
            scale: 0.1,
            unscaledPos: new Point(),
          };

          let startplanets = [];
          for (let i=0;i<this.sun.satelites.length;++i) {
            if (!(this.sun.satelites[i] instanceof Planet))
              continue;
            startplanets.push(this.sun.satelites[i]);
          }

          this.man = new Man(this.random.choice(startplanets).pos, this.random);
          this.man.mode = 'rocket';

          this.setCenter(new Point(0,0), 0.05, true);

          this.frame = 0;
        }
      };

      MovingRect.prototype.setRandom = function(seed) {
        if (!seed)
          seed = `${Math.random()}`.replace('0\.', '');
        this.random = new Random(seed);
        console.log(`#${seed}`);
      }

      MovingRect.prototype.setCenter = function(pos, scale, immidiate) {
        if (immidiate) {
          this.unscaledPos = pos;
          if (scale) {
            this.trans.scale = scale;
          }
        } else {
          if (scale) {
            let ds = scale - this.trans.scale;
            this.trans.scale += Math.sqrt(Math.abs(ds))*Math.sign(ds)/(window.scaleSpeed||200);
          }
          let d = Point.fromPos(pos).sub(this.unscaledPos);
          this.unscaledPos.x += Math.sqrt(Math.abs(d.x))*Math.sign(d.x)*2;
          this.unscaledPos.y += Math.sqrt(Math.abs(d.y))*Math.sign(d.y)*2;
          if (window.paused) {
            this.unscaledPos = pos;
          }
        }
        let t = Point.fromPos(this.width/2, this.height/2).sub(Point.fromPos(this.unscaledPos).mul(this.trans.scale));
        this.trans.pos = t;
      }

      MovingRect.prototype.genaratePlanets = function() {
        if (this.random.choice([0, 1]))
          this.sun = new Sun(this.random, 1000*10, 1000);
        else
          this.sun = new BlackHole(this.random, 1000*10, 1000);
        this.sun.populate(getParam('population'));
      }

      MovingRect.prototype.genarateStars = function(size) {
        this.starsSize = size || 2048;
        window.renderer.setPositions();
        window.renderer.useProgram('space-texture');
        let params = {
          random:this.random.rand(),
          dust:this.random.range(-1,1),
          stars: this.random.range(0.1,0.99),
          smallstars: this.random.range(0.98,0.999),
        };
        this.stars = window.renderer.texture(params, this.starsSize, {MIN_FILTER: window.renderer.gl.LINEAR});
        
        window.renderer.useProgram('galaxy');
        for (let i=0; i<this.random.gauss(10, 5); ++i) {
          params = {
            roll: this.random.range(0.1,Math.PI/2),
            spin: Math.PI*this.random.range(3, 4),
            arms: Math.round(this.random.choice([0, 2, 2, 2, 3, 4, 4])),
            opacity: this.random.range(0.5,1),
            armscolor: [this.random.range(1), this.random.range(1), this.random.range(1)], //[.1, 0.2, 1.]
            bulgeColor: [this.random.range(1), this.random.range(1), this.random.range(1)], //[1., 1., 0.5],
            dustcolor: [0.4, 0, 0],
            perspective: this.random.range(0,1),
            bulge: this.random.gauss(2, 0.2),
            random: this.random.rand()*1234,
          };
          if (params.arms == 0)params.bulge = this.random.gauss(1, 0.1);
          x = this.starsSize/2 - this.random.range(this.starsSize);
          y = this.starsSize/2 - this.random.range(this.starsSize);
          a = this.random.range(Math.PI);
          s = this.starsSize/2 * (Math.pow(this.random.gauss(0, 0.3), 2) + 0.02);

          window.renderer.renderTo(this.stars, this.starsSize, params, x, y, s, s, a);
          if (x-s<0 || x+s>this.starsSize)
            window.renderer.renderTo(this.stars, this.starsSize, params, x+this.starsSize, y, s, s, a);
          if (y-s<0 || y+s>this.starsSize)
            window.renderer.renderTo(this.stars, this.starsSize, params, x, y+this.starsSize, s, s, a);
          if ((x-s<0 || x+s>this.starsSize) && (y-s<0 || y+s>this.starsSize))
            window.renderer.renderTo(this.stars, this.starsSize, params, x+this.starsSize, y+this.starsSize, s, s, a);
        }
      }

      MovingRect.prototype.drawStars = function() {
        let d = Point.fromPos(this.sun.pos).sub(this.trans.pos).mul(-0.1);
        window.renderer.useProgram('space');
        window.renderer.render({image:this.stars}, d.x, d.y, this.starsSize);
        
        if (this.sun instanceof BlackHole) {
          this.sun.params.s_position = [d.x, d.y];
          this.sun.params.s_scale = [this.starsSize, this.starsSize];
          this.sun.params.image = this.stars;
          let scaledPos = this.sun.pos.scaled(this.trans);
          let radius = Math.min(this.sun.radius/this.sun.params.radius, 1500);

          window.renderer.useProgram('black-hole').renderer.render(
            this.sun.params,
            scaledPos.x, scaledPos.y,
            radius*this.trans.scale, radius*this.trans.scale,
            0
          );
        }

        if (window.testGalaxy) {
          window.renderer.useProgram('galaxy');
          window.renderer.render({roll:this.frame/100, spin:25, arms:1,frame:this.frame/100, opacity:1}, 266, 266, 266, 266, .5);
        }
      }

      MovingRect.prototype.drawPlanets = function() {
        function drawOrbit(trans) {
          if (this.drawOrbit && this.orbit.radius>0) {
            let scaledPos = this.parent.pos.scaled(trans);
            window.renderer.useProgram('orbit');
            let dashes =  Math.ceil(this.orbit.radius*trans.scale/2);
            params = {color:this.params.groundcolor, dashes:dashes, angle:this.orbit.angle, speed: this.orbit.speed*100, type:window.orbitType};
            window.renderer.render(params, scaledPos.x, scaledPos.y, this.orbit.radius*trans.scale);
          }
        }

        if (window.orbitType) {
          renderer.setPositions('orbit');
          this.sun.eachSatelite(drawOrbit, this.trans);
          renderer.setPositions();
        }

        this.sun.draw(this.trans);

        if (this.man && this.man.onPlanet) {
          let size = Math.min(this.width, this.height)/4.5;
          this.man.onPlanet.program.use().renderer.render(this.man.onPlanet.params, size, size, size*0.8, this.man.onPlanet.rotation);
        }
      }

      MovingRect.prototype.drawMan = function() {
        if(window.hideMan) return;
        // if (this.manNewPos) {
        //   window.renderer.useProgram('fill');
        //   let scaledPos = this.manNewPos.pos.scaled(this.trans);
        //   window.renderer.render({color:[1,0,0]}, scaledPos.x, scaledPos.y, 10);
        // }

        let scaledPos = this.man.pos.scaled(this.trans);
        let t, a = this.man.a;

        if (this.man.thrust.on && !this.man.onPlanet) {
          renderer.setPositions('flame');
          window.renderer.useProgram('flame');
          if (this.man.thrust.u) {
            t = Point.fromPos(scaledPos).add(Point.fromPolar(a, -10));
            window.renderer.render({color:[1.0,0.5,1.0], frame:this.man.frame, thrust:this.man.thrust.u}, t.x, t.y, 10, 30, -a-Math.PI/2);
          }
          let l = 1, r = 0;
          if (this.man.thrust.d) {
            if (this.man.thrust.r) l=0.75;
            else l = 0.5;
            if (this.man.thrust.l) r=-0.25;
            else r = -0.5;
          }
          if (this.man.thrust.d || this.man.thrust.r) {
            let thrust = ((this.man.thrust.d||0)+(this.man.thrust.r||0))/(!!this.man.thrust.d+!!this.man.thrust.r);
            t = Point.fromPos(scaledPos).
              add(Point.fromPolar(a, 25)).
              add(Point.fromPolar(a-Math.PI/2, 10));
            window.renderer.render({color:[0.1,0.5,1.0], frame:this.man.frame, thrust:thrust}, t.x, t.y, 5, 20, -a+Math.PI*l);
          }
          if (this.man.thrust.d || this.man.thrust.l) {
            let thrust = ((this.man.thrust.d||0)+(this.man.thrust.l||0))/(!!this.man.thrust.d+!!this.man.thrust.l);
            t = Point.fromPos(scaledPos).
              add(Point.fromPolar(a, 25)).
              add(Point.fromPolar(a-Math.PI/2, -10));
           window.renderer.render({color:[0.1,0.5,1.0], frame:this.man.frame, thrust:thrust}, t.x, t.y, 5, 20,  -a-Math.PI*r);
          }
          renderer.setPositions();
        }

        let s = Point.fromPolar(Point.fromPos(this.man.pos).ang() - Math.PI/2-a, 1);
        let lightdirection = [s.x, s.y, 1];
        
        t = Point.fromPos(scaledPos).add(Point.fromPolar(a, 20));
        window.renderer.useProgram('rocket');
        window.renderer.render(Object.assign({lightdirection:lightdirection}, this.man.params), t.x, t.y, 30, 30, -a+Math.PI/2);
      }

      MovingRect.prototype.moveRockets = function() {
        for (let rocket of this.rockets) {
          rocket.move(this.sun);
          if (rocket.onPlanet) {
            this.rockets.delete(rocket);
          }
        }
      }

      MovingRect.prototype.drawRockets = function() {
        for (let rocket of this.rockets) {
          let s = Point.fromPolar(Point.fromPos(rocket.pos).ang() - Math.PI/2 - rocket.a, 1);
          let lightdirection = [-s.x, -s.y, 1];
          let t = rocket.pos.scaled(this.trans);
          if (rocket.fuel > 0) {
            let t1 = Point.fromPos(t).add(Point.fromPolar(rocket.a, 15));
            window.renderer.setPositions('flame');
            window.renderer.useProgram('flame');
            window.renderer.render({color:[1.0,0.5,0.5], frame:this.man.frame, thrust:1}, t1.x, t1.y, 5, 10, -rocket.a+Math.PI/2);
            window.renderer.setPositions();
          }
          window.renderer.useProgram('rocket');
          window.renderer.render(Object.assign({lightdirection:lightdirection}, rocket.params), t.x, t.y, 20, 20, -rocket.a-Math.PI/2);
        }
      }

      MovingRect.prototype.draw = function() {
        window.renderer.clear();

        if (!window.paused)
          this.sun.move();
        if (this.man)
          this.man.move(this.sun);
        this.moveRockets();

        this.drawStars();
        this.drawPlanets();
        this.drawRockets();
        if (this.man && !this.man.onPlanet)
          this.drawMan();

        if (this.man) {
          let c = this.man.onPlanet ? this.man.onPlanet.pos : this.man.pos;
          // if (window.pos) c = window.pos;
          if (window.scale)  {
            if (this.trans.scale < 0.1)
              c = new Point(0, 0);
            this.setCenter(c, window.scale);
          } else {
            this.setCenter(c, this.man.thrust.u || this.man.thrust.d || (window.hideMan && (this.man.thrust.l || this.man.thrust.r)) ? 0.1 : 0.2);
          }
        }
        this.frame++;
        requestAnimationFrame(()=>{this.draw()});
      };
    </script>
  </head>
  <body style="margin: 0px; overflow: hidden">
    <canvas id="canvas" width="500" height="500" style="background: #000; margin: 0px; overflow: hidden; touch-action: none;"></canvas>
  </body>
  <script>
    const canvas = document.getElementById('canvas');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    mr = new MovingRect(canvas);
    mr.draw();
    window.orbitType = 3;

    let favicon = document.createElement('canvas');
    favicon.width = favicon.height = 16;
    let faviconctx = favicon.getContext('2d');
    let gradient =
      faviconctx.createRadialGradient(8, 8, 10, 10, 14, 9);
    gradient.addColorStop(0.0, '#f00');
    gradient.addColorStop(0.4, '#030');
    gradient.addColorStop(1, '#abc');
    faviconctx.fillStyle = gradient;
    faviconctx.beginPath();
    faviconctx.arc(favicon.width/2, favicon.height/2, favicon.width/2, 0, 2 * Math.PI);
    faviconctx.fill();

    let link = document.createElement('link');
    link.type = 'image/x-icon';
    link.rel = 'shortcut icon';
    link.href = favicon.toDataURL("image/x-icon");
    document.getElementsByTagName('head')[0].appendChild(link);

    document.addEventListener('keydown', function(e) {
      if (e.repeat) { return }
      window.keys = window.keys || {};
      window.keys[e.code] = true;
      switch (e.code) {
        case 'ArrowDown': case 'KeyS': mr.man.thrust.d = true; mr.manNewPos=false; break;
        case 'ArrowUp': case 'KeyW': mr.man.thrust.u = true; mr.manNewPos=false; break;
        case 'ArrowLeft': case 'KeyA': mr.man.thrust.l = true; mr.manNewPos=false; break;
        case 'ArrowRight': case 'KeyD': mr.man.thrust.r = true; mr.manNewPos=false; break;
        case 'NumpadAdd': case 'Equal': window.scale = window.hideMan ? 0.6 : 0.4; break;
        case 'NumpadSubtract': case 'Minus': window.scale = 0.05; break;
      }
      // console.log(e.code);
    });

    document.addEventListener('keyup', function(e) {
      window.keys = window.keys || {};
      window.keys[e.code] = false;
      switch (e.code) {
        case 'ArrowDown': case 'KeyS': mr.man.thrust.d = false; break;
        case 'ArrowUp': case 'KeyW': mr.man.thrust.u = false; break;
        case 'ArrowLeft': case 'KeyA': mr.man.thrust.l = false; break;
        case 'ArrowRight': case 'KeyD': mr.man.thrust.r = false; break;
        case 'Space': mr.man.fireRocket(mr); break;
        case 'NumpadAdd': case 'Equal':
        case 'NumpadSubtract': case 'Minus': window.scale = false; break;
        case 'KeyO': window.orbitType = (window.orbitType+1)%4; break;
        case 'KeyP': window.paused = !window.paused; break;
        case 'Digit1':
          if (mr.man.onPlanet) {
            mr.man.onPlanet.params.random = mr.man.onPlanet.random.rand()*1110;
            mr.man.onPlanet.generateTex();
          }
        break;
        case 'Digit2':
          if (mr.man.onPlanet) {
            mr.man.onPlanet.roll();
            mr.man.onPlanet.generateTex();
          }
        break;
        case 'Digit3':
          if (mr.man.onPlanet) {
            if (mr.man.onPlanet.rings)
              delete mr.man.onPlanet.rings;
            else
              mr.man.onPlanet.generateRings();
          }
        break;
        case 'Digit4':
          let satelites = mr.sun.satelites;
          if (mr.random.choice([0, 1]))
            mr.sun = new Sun(mr.random, 1000*10, 1000);
          else
            mr.sun = new BlackHole(mr.random, 1000*10, 1000);
          for (let i=0; i<satelites.length;++i)
            satelites[i].parent = mr.sun;
          mr.sun.satelites = satelites;
        break;
        case 'Digit5':
          mr.setRandom();
          mr.genarateStars();
          mr.genaratePlanets();
          mr.man.onPlanet=false;
        break;
        case 'Digit6':
          mr.genarateStars();
          mr.man.onPlanet=false;
        break;
        case 'KeyZ': mr.man.dp.set(0,0); break;
        case 'KeyG': window.testGalaxy = !window.testGalaxy; break;
        case 'KeyH': window.hideMan = !window.hideMan; mr.man.onPlanet=false; break;
      }

    });
    window.addEventListener("resize", (event) => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      window.renderer.gl.canvas.width = canvas.width;
      window.renderer.gl.canvas.height = canvas.height;
      window.renderer.gl.viewport(0, 0, window.renderer.gl.canvas.width, window.renderer.gl.canvas.height);
      for (program in window.renderer.programs) {
        let p = window.renderer.programs[program];
        p.use();
        window.renderer.gl.uniform2f(window.renderer.gl.getUniformLocation(p.program, "u_resolution"), canvas.width, canvas.height);
      }
      mr.width = canvas.getBoundingClientRect().width;
      mr.height = canvas.getBoundingClientRect().height;
    });

    function setDirectionPoint(event) {
      event.preventDefault();
      const rect = event.target.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;

      let pos = new Point(0, 0).sub(mr.trans.pos);
      let ppos = new Point(x, y).mul(1/mr.trans.scale).add(pos);

      let xx = (x-mr.trans.pos.x)/mr.trans.scale;
      let yy = (y-mr.trans.pos.y)/mr.trans.scale;

      if (this.onPlanet) {
        mr.man.onPlanet = false;
        mr.man.takingOff = this.onPlanet;
      }

      mr.manNewPos = {pos:new Point(xx, yy)};
      mr.sun.eachSatelite(function(obj) {
        if (!(this instanceof Planet)) return;
        let dp = Point.fromPos(mr.manNewPos.pos).sub(this.pos);
          if (dp.len() < this.radius) {
            mr.manNewPos = this;
            //console.log(mr.manNewPos);
            return true;
          }
      }, this);
    }

    document.addEventListener("click", setDirectionPoint);
    document.addEventListener("tap", setDirectionPoint);

    const pinchZoom = (imageElement) => {
      let imageElementScale = 1, o;

      let start = {};

      // Calculate distance between two fingers
      const distance = (event) => {
        return Math.hypot(event.touches[0].pageX - event.touches[1].pageX, event.touches[0].pageY - event.touches[1].pageY);
      };

      imageElement.addEventListener('touchstart', (event) => {
        //console.log('touchstart', event.touches.length);
        if (event.touches.length === 2) {
          event.preventDefault(); // Prevent page scroll

          // Calculate where the fingers have started on the X and Y axis
          start.x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
          start.y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
          start.distance = distance(event);
          start.scale = mr.trans.scale;
        }
      });

      imageElement.addEventListener('touchmove', (event) => {
        if (event.touches.length === 2) {
          event.preventDefault(); // Prevent page scroll

          // Safari provides event.scale as two fingers move on the screen
          // For other browsers just calculate the scale manually
          let scale;
          if (event.scale) {
            scale = event.scale;
          } else {
            const deltaDistance = distance(event);
            scale = deltaDistance / start.distance;
          }
          imageElementScale = Math.min(Math.max(0.1, scale), 5);

          // Calculate how much the fingers have moved on the X and Y axis
          //const deltaX = (((event.touches[0].pageX + event.touches[1].pageX) / 2) - start.x) * 2; // x2 for accelarated movement
          //const deltaY = (((event.touches[0].pageY + event.touches[1].pageY) / 2) - start.y) * 2; // x2 for accelarated movement

          window.scale = start.scale * imageElementScale;
          window.scale = Math.min(Math.max(0.05, window.scale), 1);
          window.scaleSpeed = 20;
          /*const x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
          const y = (event.touches[0].pageX + event.touches[1].pageX) / 2;

          let pos = new Point(0, 0).sub(mr.trans.pos);
          let ppos = new Point(x, y).mul(1/mr.trans.scale).add(pos);

          let xx = (x-mr.trans.pos.x)/mr.trans.scale;
          let yy = (y-mr.trans.pos.y)/mr.trans.scale;

          window.pos = new Point(xx, yy);*/

        }
      });

      imageElement.addEventListener('touchend', (event) => {
        //console.log('touchend');
        window.scale = false;
        window.scaleSpeed = false;
        //window.pos = false;
      });
    }
    pinchZoom(canvas);
  </script>
</html>
